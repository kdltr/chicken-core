;;;; types.db - Type-information for core library functions -*- Scheme -*-
;
; Copyright (c) 2009-2017, The CHICKEN Team
; All rights reserved.
;
; Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following
; conditions are met:
;
;   Redistributions of source code must retain the above copyright notice, this list of conditions and the following
;     disclaimer. 
;   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
;     disclaimer in the documentation and/or other materials provided with the distribution. 
;   Neither the name of the author nor the names of its contributors may be used to endorse or promote
;     products derived from this software without specific prior written permission. 
;
; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
; OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
; AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR
; CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION HOWEVER CAUSED AND ON ANY
; THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
; OTHERWISE ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
; POSSIBILITY OF SUCH DAMAGE.


;;; Notes:
;
; - numeric types are disjoint, "fixnum" or "float" will not match "number" in the
;   rewrite rules
; - for a description of the type-specifier syntax, see "scrutinizer.scm" (top of file)
; - in templates, "#(INTEGER)" refers to the INTEGERth argument (starting from 1)
; - in templates, "#(INTEGER ...)" refers to the INTEGERth argument (starting from 1) and
;   all remaining arguments
; - in templates "#(SYMBOL)" binds X to a temporary gensym'd variable, further references
;   to "#(SYMBOL)" allow backreferences to this generated identifier
; - "#(procedure PROPERTY ...)" may be used in place of "procedure", properties are:
;     #:clean - procedure does not modify state that might be used locally
;     #:enforce - when procedure returns, arguments are of correct type
;     #:foldable - procedure may be constant-folded
;     #:predicate TYPE - procedure is a predicate on TYPE (implies #:foldable)
;     #:pure - procedure has no side effects
; - "#:clean" means: will not invoke procedures that modify local variables and
;   will not modify list or vector data held locally (note that I/O may invoke
;   port handlers)
; - "#:pure" means: will not have side-effects; this is a bit of a lie,
;   since arity-mismatch will for example always have a side effect.
; - "#:enforce" means: after return from this procedure, the argument is of
;   the correct type (it would have signalled an error otherwise)
; - "#:foldable" means: when applied to constant arguments, direct calls
;   to this procedure may be evaluated at compile time.


;; scheme

(not (#(procedure #:pure #:foldable) not (*) boolean)
     ((true) (false) (let ((#(tmp) #(1))) '#f))
     ((false) (true) (let ((#(tmp) #(1))) '#t))
     (((not boolean)) (false) (let ((#(tmp) #(1))) '#f)))

(boolean? (#(procedure #:pure #:predicate boolean) boolean? (*) boolean))

(eq? (#(procedure #:pure #:foldable) eq? (* *) boolean))

(eqv? (#(procedure #:pure #:foldable) eqv? (* *) boolean)
      (((or immediate symbol) *) (eq? #(1) #(2)))
      ((* (or immediate symbol)) (eq? #(1) #(2)))
      ((* *) (##core#inline "C_i_eqvp" #(1) #(2))))

(equal? (#(procedure #:pure #:foldable) equal? (* *) boolean)
	(((or immediate symbol) *) (eq? #(1) #(2)))
	((* (or immediate symbol)) (eq? #(1) #(2)))
	((number number) (##core#inline "C_i_eqvp" #(1) #(2))))

(pair? (#(procedure #:pure #:predicate pair) pair? (*) boolean))

(cons (forall (a b) (#(procedure #:pure) cons (a b) (pair a b))))

(##sys#cons (forall (a b) (#(procedure #:pure) ##sys#cons (a b) (pair a b))))

(car (forall (a) (#(procedure #:clean #:enforce #:foldable) car ((pair a *)) a)) ((pair) (##core#inline "C_u_i_car" #(1))))
(cdr (forall (a) (#(procedure #:clean #:enforce #:foldable) cdr ((pair * a)) a)) ((pair) (##core#inline "C_u_i_cdr" #(1))))

(caar (forall (a) (#(procedure #:clean #:enforce #:foldable) caar ((pair (pair a *) *)) a))
      (((pair (pair * *) *)) (##core#inline "C_u_i_car" (##core#inline "C_u_i_car" #(1)))))
(cadr (forall (a) (#(procedure #:clean #:enforce #:foldable) cadr ((pair * (pair a *))) a))
      (((pair * (pair * *))) (##core#inline "C_u_i_car" (##core#inline "C_u_i_cdr" #(1)))))
(cdar (forall (a) (#(procedure #:clean #:enforce #:foldable) cdar ((pair (pair * a) *)) a))
      (((pair (pair * *) *)) (##core#inline "C_u_i_cdr" (##core#inline "C_u_i_car" #(1)))))
(cddr (forall (a) (#(procedure #:clean #:enforce #:foldable) cddr ((pair * (pair * a))) a))
      (((pair * (pair * *))) (##core#inline "C_u_i_cdr" (##core#inline "C_u_i_cdr" #(1)))))

(caaar (forall (a) (#(procedure #:clean #:enforce #:foldable) caaar ((pair (pair (pair a *) *) *)) a))
       (((pair (pair (pair * *) *) *))
	(##core#inline "C_u_i_car"
		       (##core#inline "C_u_i_car" (##core#inline "C_u_i_car" #(1))))))

(caadr (forall (a) (#(procedure #:clean #:enforce #:foldable) caadr ((pair * (pair (pair a *) *))) a))
       (((pair * (pair (pair * *) *)))
	(##core#inline "C_u_i_car"
		       (##core#inline "C_u_i_car" (##core#inline "C_u_i_cdr" #(1))))))

(cadar (forall (a) (#(procedure #:clean #:enforce #:foldable) cadar ((pair (pair * (pair a *)) *)) a))
       (((pair (pair * (pair * *)) *))
	(##core#inline "C_u_i_car"
		       (##core#inline "C_u_i_cdr" (##core#inline "C_u_i_car" #(1))))))

(caddr (forall (a) (#(procedure #:clean #:enforce #:foldable) caddr ((pair * (pair * (pair a *)))) a))
       (((pair * (pair * (pair * *))))
	(##core#inline "C_u_i_car"
		       (##core#inline "C_u_i_cdr" (##core#inline "C_u_i_cdr" #(1))))))

(cdaar (forall (a) (#(procedure #:clean #:enforce #:foldable) cdaar ((pair (pair (pair * a) *) *)) a))
       (((pair (pair (pair * *) *) *))
	(##core#inline "C_u_i_cdr"
		       (##core#inline "C_u_i_car" (##core#inline "C_u_i_car" #(1))))))

(cdadr (forall (a) (#(procedure #:clean #:enforce #:foldable) cdadr ((pair * (pair (pair * a) *))) a))
       (((pair * (pair (pair * *) *)))
	(##core#inline "C_u_i_cdr"
		       (##core#inline "C_u_i_car" (##core#inline "C_u_i_cdr" #(1))))))

(cddar (forall (a) (#(procedure #:clean #:enforce #:foldable) cddar ((pair (pair * (pair * a)) *)) a))
       (((pair (pair * (pair * *)) *))
	(##core#inline "C_u_i_cdr"
		       (##core#inline "C_u_i_cdr" (##core#inline "C_u_i_car" #(1))))))

(cdddr (forall (a) (#(procedure #:clean #:enforce #:foldable) cdddr ((pair * (pair * (pair * a)))) a))
       (((pair * (pair * (pair * *))))
	(##core#inline "C_u_i_cdr"
		       (##core#inline "C_u_i_cdr" (##core#inline "C_u_i_cdr" #(1))))))

(caaaar (forall (a) (#(procedure #:clean #:enforce #:foldable) caaaar ((pair (pair (pair (pair a *) *) *) *)) a)))
(caaadr (forall (a) (#(procedure #:clean #:enforce #:foldable) caaadr ((pair * (pair (pair (pair a *) *) *))) a)))
(caadar (forall (a) (#(procedure #:clean #:enforce #:foldable) caadar ((pair (pair * (pair (pair a *) *)) *)) a)))
(caaddr (forall (a) (#(procedure #:clean #:enforce #:foldable) caaddr ((pair * (pair * (pair (pair a *) *)))) a)))
(cadaar (forall (a) (#(procedure #:clean #:enforce #:foldable) cadaar ((pair (pair (pair * (pair a *)) *) *)) a)))
(cadadr (forall (a) (#(procedure #:clean #:enforce #:foldable) cadadr ((pair * (pair (pair * (pair a *)) *))) a)))
(caddar (forall (a) (#(procedure #:clean #:enforce #:foldable) caddar ((pair (pair * (pair * (pair a *))) *)) a)))
(cadddr (forall (a) (#(procedure #:clean #:enforce #:foldable) cadddr ((pair * (pair * (pair * (pair a *))))) a)))
(cdaaar (forall (a) (#(procedure #:clean #:enforce #:foldable) cdaaar ((pair (pair (pair (pair * a) *) *) *)) a)))
(cdaadr (forall (a) (#(procedure #:clean #:enforce #:foldable) cdaadr ((pair * (pair (pair (pair * a) *) *))) a)))
(cdadar (forall (a) (#(procedure #:clean #:enforce #:foldable) cdadar ((pair (pair * (pair (pair * a) *)) *)) a)))
(cdaddr (forall (a) (#(procedure #:clean #:enforce #:foldable) cdaddr ((pair * (pair * (pair (pair * a) *)))) a)))
(cddaar (forall (a) (#(procedure #:clean #:enforce #:foldable) cddaar ((pair (pair (pair * (pair * a)) *) *)) a)))
(cddadr (forall (a) (#(procedure #:clean #:enforce #:foldable) cddadr ((pair * (pair (pair * (pair * a)) *))) a)))
(cdddar (forall (a) (#(procedure #:clean #:enforce #:foldable) cdddar ((pair (pair * (pair * (pair * a))) *)) a)))
(cddddr (forall (a) (#(procedure #:clean #:enforce #:foldable) cddddr ((pair * (pair * (pair * (pair * a))))) a)))

(set-car! (#(procedure #:enforce) set-car! (pair *) undefined) 
	  ((pair (or fixnum char boolean eof null undefined)) (##sys#setislot #(1) '0 #(2)))
	  ((pair *) (##sys#setslot #(1) '0 #(2))))

(set-cdr! (#(procedure #:enforce) set-cdr! (pair *) undefined)
	  ((pair (or fixnum char boolean eof null undefined)) (##sys#setislot #(1) '1 #(2)))
	  ((pair *) (##sys#setslot #(1) '1 #(2))))

(null? (#(procedure #:pure #:predicate null) null? (*) boolean))
(list? (#(procedure #:pure #:predicate list) list? (*) boolean))

;; special cased (see scrutinizer.scm)
(list (#(procedure #:pure) list (#!rest) list))
(##sys#list (#(procedure #:pure) ##sys#list (#!rest) list))

(length (#(procedure #:clean #:enforce #:foldable) length (list) fixnum) ; may loop
	((null) (let ((#(tmp) #(1))) '0))
	((list) (##core#inline "C_u_i_length" #(1))))

(##sys#length (#(procedure #:clean #:enforce #:foldable) ##sys#length (list) fixnum)
	      ((null) (let ((#(tmp) #(1))) '0))
	      ((list) (##core#inline "C_u_i_length" #(1))))

;; these are special cased (see scrutinizer.scm)
(list-tail (forall (a) (#(procedure #:clean #:enforce #:foldable) list-tail ((list-of a) fixnum) (list-of a))))
(list-ref (forall (a) (#(procedure #:clean #:enforce #:foldable) list-ref ((list-of a) fixnum) a)))

;; special cased (see scrutinizer.scm)
(append (#(procedure #:clean) append (#!rest *) *)) ; sic
(##sys#append (#(procedure #:clean) ##sys#append (#!rest *) *))

;; special cased (see scrutinizer.scm)
(reverse (forall (a) (#(procedure #:clean #:enforce) reverse ((list-of a)) (list-of a)))
         ((null) (null) (let ((#(tmp) #(1))) '())))

(memq (forall (a b) (#(procedure #:clean #:foldable) memq (a (list-of b))
		     (or false (pair a (list-of b)))))
      ((* null) (let ((#(tmp) #(1))) '#f))
      ((* list) (##core#inline "C_u_i_memq" #(1) #(2))))

(memv (forall (a b) (#(procedure #:clean #:foldable) memv (a (list-of b))
		     (or false (pair a (list-of b)))))
      ((* null) (let ((#(tmp) #(1))) '#f))
      (((or symbol procedure immediate) list)
       (##core#inline "C_u_i_memq" #(1) #(2))))

(member (forall (a b) (#(procedure #:clean #:foldable) member (a (list-of b))
		       (or false (pair a (list-of b)))))
	((* null) (let ((#(tmp) #(1))) '#f))
	(((or symbol procedure immediate) list)
	 (##core#inline "C_u_i_memq" #(1) #(2)))
	((* (list-of (or symbol procedure immediate)))
	 (##core#inline "C_u_i_memq" #(1) #(2))))

(assq (forall (a b c) (#(procedure #:clean #:foldable) assq
                       (a (list-of (pair b c)))
                       (or false (pair a c))))
      ((* null) (let ((#(tmp) #(1))) '#f))
      ((* (list-of pair)) (##core#inline "C_u_i_assq" #(1) #(2))))

(assv (forall (a b c) (#(procedure #:clean #:foldable) assv
                       (a (list-of (pair b c)))
                       (or false (pair a c))))
      ((* null) (let ((#(tmp) #(1))) '#f))
      (((or symbol immediate procedure) (list-of pair))
       (##core#inline "C_u_i_assq" #(1) #(2)))
      ((* (list-of (pair (or symbol procedure immediate) *)))
       (##core#inline "C_u_i_assq" #(1) #(2))))

(assoc (forall (a b c) (#(procedure #:clean #:foldable) assoc
			(a (list-of (pair b c)))
			(or false (pair a c))))
       ((* null) (let ((#(tmp) #(1))) '#f))
       (((or symbol procedure immediate) (list-of pair))
	(##core#inline "C_u_i_assq" #(1) #(2)))
       ((* (list-of (pair (or symbol procedure immediate) *)))
	(##core#inline "C_u_i_assq" #(1) #(2))))

(symbol? (#(procedure #:pure #:predicate symbol) symbol? (*) boolean))

(symbol-append (#(procedure #:clean #:enforce #:foldable) symbol-append (#!rest symbol) symbol))
(symbol->string (#(procedure #:clean #:enforce) symbol->string (symbol) string))
(string->symbol (#(procedure #:clean #:enforce #:foldable) string->symbol (string) symbol))

(number? (#(procedure #:pure #:predicate number) number? (*) boolean))

;;XXX predicate?
(integer? (#(procedure #:pure #:foldable) integer? (*) boolean)
	  ((integer) (let ((#(tmp) #(1))) '#t))
	  ((float) (##core#inline "C_u_i_fpintegerp" #(1)))
	  ((*) (##core#inline "C_i_integerp" #(1))))
(exact-integer? (#(procedure #:pure #:foldable) exact-integer? (*) boolean)
		((integer) (let ((#(tmp) #(1))) '#t))
		(((not integer)) (let ((#(tmp) #(1))) '#f))
		((*) (##core#inline "C_i_exact_integerp" #(1))))

(real? (#(procedure #:pure #:foldable) real? (*) boolean)
       (((or fixnum float bignum ratnum)) (let ((#(tmp) #(1))) '#t))
       ((cplxnum) (let ((#(tmp) #(1))) '#f))
       ((*) (##core#inline "C_i_realp" #(1))))
(complex? (#(procedure #:pure #:predicate number) complex? (*) boolean))
(exact? (#(procedure #:clean #:enforce #:foldable) exact? (number) boolean)
        (((or integer ratnum)) (let ((#(tmp) #(1))) '#t))
        ((float) (let ((#(tmp) #(1))) '#f)))
(inexact? (#(procedure #:clean #:enforce #:foldable) inexact? (number) boolean)
          (((or integer ratnum)) (let ((#(tmp) #(1))) '#f))
          ((float) (let ((#(tmp) #(1))) '#t)))

;;XXX predicate?
(rational? (#(procedure #:pure #:foldable) rational? (*) boolean)
	   (((or fixnum bignum ratnum)) (let ((#(tmp) #(1))) '#t))
	   ((cplxnum) (let ((#(tmp) #(1))) '#f))
	   ((float) (##core#inline "C_u_i_flonum_finitep" #(1)))
	   ((*) (##core#inline "C_i_rationalp" #(1))))

(zero? (#(procedure #:clean #:enforce #:foldable) zero? (number) boolean)
       ((integer) (eq? #(1) '0))
       (((or cplxnum ratnum)) (let ((#(tmp) #(1))) '#f))
       ((number) (##core#inline "C_u_i_zerop" #(1)))
       ((*) (##core#inline "C_i_zerop" #(1))))

(odd? (#(procedure #:clean #:enforce #:foldable) odd? (number) boolean)
	       ((fixnum) (##core#inline "C_i_fixnumoddp" #(1)))
               ((integer) (##core#inline "C_i_integer_oddp" #(1)))
               ((*) (##core#inline "C_i_oddp" #(1))))
(even? (#(procedure #:clean #:enforce #:foldable) even? (number) boolean)
	       ((fixnum) (##core#inline "C_i_fixnumevenp" #(1)))
               ((integer) (##core#inline "C_i_integer_evenp" #(1)))
               ((*) (##core#inline "C_i_evenp" #(1))))

(positive? (#(procedure #:clean #:enforce #:foldable) positive? (number) boolean)
	   ((fixnum) (##core#inline "C_i_fixnum_positivep" #(1)))
	   ((integer) (##core#inline "C_i_integer_positivep" #(1)))
	   ((*) (##core#inline "C_i_positivep" #(1))))

(negative? (#(procedure #:clean #:enforce #:foldable) negative? (number) boolean)
	   ((fixnum) (##core#inline "C_i_fixnum_negativep" #(1)))
	   ((integer) (##core#inline "C_i_integer_negativep" #(1)))
	   ((*) (##core#inline "C_i_negativep" #(1))))

(max (#(procedure #:clean #:enforce #:foldable) max (#!rest number) number)
     ((fixnum fixnum) (chicken.fixnum#fxmax #(1) #(2)))
     ((float float) (##core#inline "C_i_flonum_max" #(1) #(2))))

(min (#(procedure #:clean #:enforce #:foldable) min (#!rest number) number)
     ((fixnum fixnum) (chicken.fixnum#fxmin #(1) #(2)))
     ((float float) (##core#inline "C_i_flonum_min" #(1) #(2))))

(+ (#(procedure #:clean #:enforce #:foldable) + (#!rest number) number)
   (() (fixnum) '0)
   ((fixnum) (fixnum) #(1))
   ((float) (float) #(1))
   ((integer) (integer) #(1))
   ((ratnum) (ratnum) #(1))
   ((cplxnum) (cplxnum) #(1))
   ((number) (number) #(1))
   ((float fixnum) (float)
    (##core#inline_allocate 
     ("C_a_i_flonum_plus" 4) 
     #(1) 
     (##core#inline_allocate ("C_a_i_fix_to_flo" 4) #(2))))
   ((fixnum float)
    (float)
    (##core#inline_allocate 
     ("C_a_i_flonum_plus" 4) 
     (##core#inline_allocate ("C_a_i_fix_to_flo" 4) #(1))
     #(2)))
   ((float float) (float)
    (##core#inline_allocate ("C_a_i_flonum_plus" 4) #(1) #(2)))
   ((fixnum fixnum) (integer)
    (##core#inline_allocate ("C_a_i_fixnum_plus" 5) #(1) #(2)))
   ((integer integer) (integer)
    (##core#inline_allocate ("C_s_a_u_i_integer_plus" 5) #(1) #(2)))
   ((* *) (number)
    (##core#inline_allocate ("C_s_a_i_plus" 29) #(1) #(2))))

(- (#(procedure #:clean #:enforce #:foldable) - (number #!rest number) number)
   ((fixnum) (integer) (##core#inline_allocate ("C_a_i_fixnum_negate" 5) #(1)))
   ((integer) (integer)
    (##core#inline_allocate ("C_s_a_u_i_integer_negate" 5) #(1)))
   ((float) (float) (##core#inline_allocate ("C_a_i_flonum_negate" 4) #(1)))
   ((*) (*) (##core#inline_allocate ("C_s_a_i_negate" 29) #(1)))
   ((float fixnum) (float)
    (##core#inline_allocate 
     ("C_a_i_flonum_difference" 4) 
     #(1) 
     (##core#inline_allocate ("C_a_i_fix_to_flo" 4) #(2))))
   ((fixnum float) (float)
    (##core#inline_allocate 
     ("C_a_i_flonum_difference" 4) 
     (##core#inline_allocate ("C_a_i_fix_to_flo" 4) #(1))
     #(2)))
   ((float float) (float)
    (##core#inline_allocate ("C_a_i_flonum_difference" 4) #(1) #(2)))
   ((fixnum fixnum) (integer)
    (##core#inline_allocate ("C_a_i_fixnum_difference" 5) #(1) #(2)))
   ((integer integer) (integer)
    (##core#inline_allocate ("C_s_a_u_i_integer_minus" 5) #(1) #(2)))
   ((* *) (number)
    (##core#inline_allocate ("C_s_a_i_minus" 29) #(1) #(2))))

(* (#(procedure #:clean #:enforce #:foldable) * (#!rest number) number)
   (() (fixnum) '1)
   ((fixnum) (fixnum) #(1))
   ((float) (float) #(1))
   ((bignum) (bignum) #(1))
   ((integer) (integer) #(1))
   ((ratnum) (ratnum) #(1))
   ((cplxnum) (cplxnum) #(1))
   ((number) (number) #(1))
   ((float fixnum) (float)
    (##core#inline_allocate 
     ("C_a_i_flonum_times" 4) 
     #(1) 
     (##core#inline_allocate ("C_a_i_fix_to_flo" 4) #(2))))
   ((fixnum float) (float)
    (##core#inline_allocate 
     ("C_a_i_flonum_times" 4) 
     (##core#inline_allocate ("C_a_i_fix_to_flo" 4) #(1))
     #(2)))
   ((float float) (float)
    (##core#inline_allocate ("C_a_i_flonum_times" 4) #(1) #(2)))
   ((fixnum fixnum) (integer)
    (##core#inline_allocate ("C_a_i_fixnum_times" 5) #(1) #(2)))
   ((integer integer) (integer)
    (##core#inline_allocate ("C_s_a_u_i_integer_times" 5) #(1) #(2)))
   ((* *) (number)
    (##core#inline_allocate ("C_s_a_i_times" 33) #(1) #(2))))

(/ (#(procedure #:clean #:enforce #:foldable) / (number #!rest number) number)
   ((float fixnum) (float)
    ;; This is the only checked one because the divisor is an exact value
    (##core#inline_allocate
     ("C_a_i_flonum_quotient_checked" 4)
     #(1)
     (##core#inline_allocate ("C_a_i_fix_to_flo" 4) #(2))))
   ((fixnum float) (float)
    (##core#inline_allocate
     ("C_a_i_flonum_quotient" 4)
     (##core#inline_allocate ("C_a_i_fix_to_flo" 4) #(1))
     #(2)))
   ((float float) (float)
    (##core#inline_allocate ("C_a_i_flonum_quotient" 4) #(1) #(2)))
   ((integer integer) ((or integer ratnum))
    (##sys#/-2 #(1) #(2)))
   ((* *) (number)
    (##sys#/-2 #(1) #(2))))

(= (#(procedure #:clean #:enforce #:foldable) = (#!rest number) boolean)
   (() '#t)
   ((number) (let ((#(tmp) #(1))) '#t))
   ((fixnum fixnum) (eq? #(1) #(2)))
   ((float float) (##core#inline "C_flonum_equalp" #(1) #(2)))
   ((integer integer) (##core#inline "C_i_integer_equalp" #(1) #(2)))
   ((* *) (##core#inline "C_i_nequalp" #(1) #(2))))

(> (#(procedure #:clean #:enforce #:foldable) > (#!rest number) boolean)
   (() '#t)
   ((number) (let ((#(tmp) #(1))) '#t))
   ((fixnum fixnum) (chicken.fixnum#fx> #(1) #(2)))
   ((float float) (##core#inline "C_flonum_greaterp" #(1) #(2)))
   ((integer integer) (##core#inline "C_i_integer_greaterp" #(1) #(2)))
   ((* *) (##core#inline "C_i_greaterp" #(1) #(2))))

(< (#(procedure #:clean #:enforce #:foldable) < (#!rest number) boolean)
   (() '#t)
   ((number) (let ((#(tmp) #(1))) '#t))
   ((fixnum fixnum) (chicken.fixnum#fx< #(1) #(2)))
   ((integer integer) (##core#inline "C_i_integer_lessp" #(1) #(2)))
   ((float float) (##core#inline "C_flonum_lessp" #(1) #(2)))
   ((* *) (##core#inline "C_i_lessp" #(1) #(2))))

(>= (#(procedure #:clean #:enforce #:foldable) >= (#!rest number) boolean)
    (() '#t)
    ((number) (let ((#(tmp) #(1))) '#t))
    ((fixnum fixnum) (chicken.fixnum#fx>= #(1) #(2)))
    ((integer integer) (##core#inline "C_i_integer_greater_or_equalp" #(1) #(2)))
    ((float float) (##core#inline "C_flonum_greater_or_equal_p" #(1) #(2)))
    ((* *) (##core#inline "C_i_greater_or_equalp" #(1) #(2))))

(<= (#(procedure #:clean #:enforce #:foldable) <= (#!rest number) boolean)
    (() '#t)
    ((number) (let ((#(tmp) #(1))) '#t))
    ((fixnum fixnum) (chicken.fixnum#fx<= #(1) #(2)))
    ((integer integer) (##core#inline "C_i_integer_less_or_equalp" #(1) #(2)))
    ((float float) (##core#inline "C_flonum_less_or_equal_p" #(1) #(2)))
    ((* *) (##core#inline "C_i_less_or_equalp" #(1) #(2))))

(quotient (#(procedure #:clean #:enforce #:foldable) quotient ((or integer float) (or integer float)) (or integer float))
	  ;;XXX flonum/mixed case
	  ((float float) (float)
	   (##core#inline_allocate
	    ("C_a_i_flonum_actual_quotient_checked" 4) #(1) #(2)))
	  ((fixnum fixnum) (integer)
	   (##core#inline_allocate ("C_a_i_fixnum_quotient_checked" 5)
				   #(1) #(2)))
	  ((integer integer) (integer)
	   (##core#inline_allocate ("C_s_a_u_i_integer_quotient" 5) #(1) #(2)))
	  ((* *) (##core#inline_allocate ("C_s_a_i_quotient" 5) #(1) #(2))))

(remainder (#(procedure #:clean #:enforce #:foldable) remainder ((or integer float) (or integer float)) (or integer float))
	  ((float float) (float)
	   (##core#inline_allocate
	    ("C_a_i_flonum_remainder_checked" 4) #(1) #(2)))
	   ;;XXX flonum/mixed case
	   ((fixnum fixnum) (fixnum)
	    (##core#inline "C_i_fixnum_remainder_checked" #(1) #(2)))
	  ((integer integer) (integer)
	   (##core#inline_allocate ("C_s_a_u_i_integer_remainder" 5) #(1) #(2)))
	  ((* *) (##core#inline_allocate ("C_s_a_i_remainder" 5) #(1) #(2))))

(quotient&remainder (#(procedure #:clean #:enforce #:foldable) quotient&remainder ((or integer float) (or integer float)) (or integer float) (or integer float))
	  ((float float) (float float)
	   (let ((#(tmp1) #(1)))
	     (let ((#(tmp2) #(2)))
	       (##sys#values
		(##core#inline_allocate
		 ("C_a_i_flonum_actual_quotient_checked" 4) #(tmp1) #(tmp2))
		(##core#inline_allocate
		 ("C_a_i_flonum_remainder_checked" 4) #(tmp1) #(tmp2))))))
	   ;;XXX flonum/mixed case
	   ((fixnum fixnum) (integer fixnum)
	    (let ((#(tmp1) #(1)))
	      (let ((#(tmp2) #(2)))
		(##sys#values
		 (##core#inline_allocate ("C_a_i_fixnum_quotient_checked" 5)
					 #(tmp1) #(tmp2))
		 (##core#inline
		  "C_i_fixnum_remainder_checked" #(tmp1) #(tmp2))))))
	   ((integer integer) (integer integer)
	    ((##core#primitive "C_u_integer_quotient_and_remainder") #(1) #(2))))

;; TODO: Add nonspecializing type specific entries, to help flow analysis?
(quotient&modulo (#(procedure #:clean #:enforce #:foldable) quotient&modulo ((or integer float) (or integer float)) (or integer float) (or integer float)))

(modulo (#(procedure #:clean #:enforce #:foldable) modulo ((or integer float) (or integer float)) (or integer float))
	  ((float float) (float)
	   (##core#inline_allocate
	    ("C_a_i_flonum_modulo_checked" 4) #(1) #(2)))
	   ;;XXX flonum/mixed case
	   ((fixnum fixnum) (fixnum)
	    (##core#inline "C_fixnum_modulo" #(1) #(2)))
	  ((integer integer) (integer)
	   (##core#inline_allocate ("C_s_a_u_i_integer_modulo" 5) #(1) #(2)))
	  ((* *) (##core#inline_allocate ("C_s_a_i_modulo" 5) #(1) #(2))))

(gcd (#(procedure #:clean #:enforce #:foldable) gcd (#!rest (or integer float)) (or integer float))
     (() '0)
     ((fixnum fixnum) (fixnum) (chicken.fixnum#fxgcd #(1) #(2)))
     ((float float) (float) (chicken.flonum#fpgcd #(1) #(2)))
     ((integer integer) (integer)
      (##core#inline_allocate ("C_s_a_u_i_integer_gcd" 5) #(1) #(2)))
     ((* *) (##sys#gcd #(1) #(2))))

(##sys#gcd (#(procedure #:clean #:enforce #:foldable) ##sys#gcd (number number) number))

(lcm (#(procedure #:clean #:enforce #:foldable) lcm (#!rest number) number)
     (() '1)
     ((* *) (##sys#lcm #(1) #(2))))

(##sys#lcm (#(procedure #:clean #:enforce #:foldable) ##sys#lcm (number number) number))

(abs (#(procedure #:clean #:enforce #:foldable) abs (number) number)
     ((fixnum) (integer) (##core#inline_allocate ("C_a_i_fixnum_abs" 5) #(1)))
     ((float) (float) (##core#inline_allocate ("C_a_i_flonum_abs" 4) #(1)))
     ((integer) (integer)
      (##core#inline_allocate ("C_s_a_u_i_integer_abs" 5) #(1)))
     ((*) (*)
      (##core#inline_allocate ("C_s_a_i_abs" 7) #(1))))

(floor (#(procedure #:clean #:enforce #:foldable) floor ((or integer ratnum float)) (or integer ratnum float))
       ((fixnum) (fixnum) #(1))
       ((integer) (integer) #(1))
       ((float) (float)
	(##core#inline_allocate ("C_a_i_flonum_floor" 4) #(1))))

(ceiling (#(procedure #:clean #:enforce #:foldable) ceiling ((or integer ratnum float)) (or integer ratnum float))
	 ((fixnum) (fixnum) #(1))
	 ((integer) (integer) #(1))
	 ((float) (float)
	  (##core#inline_allocate ("C_a_i_flonum_ceiling" 4) #(1))))

(truncate (#(procedure #:clean #:enforce #:foldable) truncate ((or integer ratnum float)) (or integer ratnum float))
	  ((fixnum) (fixnum) #(1))
	  ((integer) (integer) #(1))
	  ((float) (float)
	   (##core#inline_allocate ("C_a_i_flonum_truncate" 4) #(1))))

(round (#(procedure #:clean #:enforce #:foldable) round ((or integer ratnum float)) (or integer ratnum float))
       ((fixnum) (fixnum) #(1))
       ((integer) (integer) #(1))
       ((float) (float)
	(##core#inline_allocate ("C_a_i_flonum_round_proper" 4) #(1))))

(exact->inexact (#(procedure #:clean #:enforce #:foldable) exact->inexact (number) (or float cplxnum))
		((float) (float) #(1))
		((fixnum) (float) (##core#inline_allocate ("C_a_i_fix_to_flo" 4) #(1)))
		((number) (##core#inline_allocate ("C_a_i_exact_to_inexact" 11) #(1))))

(inexact->exact (#(procedure #:clean #:enforce #:foldable) inexact->exact (number) (or integer ratnum))
		((fixnum) (fixnum) #(1))
		((integer) (integer) #(1))
		((ratnum) (ratnum) #(1))
		(((or integer ratnum)) #(1)))

(exp (#(procedure #:clean #:enforce #:foldable) exp (number) (or float cplxnum))
     ((float) (float) (##core#inline_allocate ("C_a_i_flonum_exp" 4) #(1))))

(log (#(procedure #:clean #:enforce #:foldable) log (number) (or float cplxnum))
     ;; Unfortunately this doesn't work when the argument is negative
     ;;((float) (float) (##core#inline_allocate ("C_a_i_flonum_log" 4) #(1)))
     ((*) (##sys#log-1 #(1))))

(expt (#(procedure #:clean #:enforce #:foldable) expt (number number) number)
      ;; This breaks in some extreme edge cases... Worth disabling?
      #;((float float) (float)
      (##core#inline_allocate ("C_a_i_flonum_expt" 4) #(1) #(2)))
      #;((float fixnum) (float)
       (##core#inline_allocate ("C_a_i_flonum_expt" 4) 
			       #(1)
			       (##core#inline_allocate ("C_a_i_fix_to_flo" 4) #(2))))
      #;((fixnum float) (float)
       (##core#inline_allocate ("C_a_i_flonum_expt" 4)
			       (##core#inline_allocate ("C_a_i_fix_to_flo" 4) #(1))
			       #(2))))

(sqrt (#(procedure #:clean #:enforce #:foldable) sqrt (number) number)
      ;; Unfortunately this doesn't work when the argument is negative
      #;((float) (float) (##core#inline_allocate ("C_a_i_flonum_sqrt" 4) #(1))))

(sin (#(procedure #:clean #:enforce #:foldable) sin (number) (or float cplxnum))
     ((float) (float) (##core#inline_allocate ("C_a_i_flonum_sin" 4) #(1))))

(cos (#(procedure #:clean #:enforce #:foldable) cos (number) (or float cplxnum))
     ((float) (float) (##core#inline_allocate ("C_a_i_flonum_cos" 4) #(1))))

(tan (#(procedure #:clean #:enforce #:foldable) tan (number) (or float cplxnum))
     ((float) (float) (##core#inline_allocate ("C_a_i_flonum_tan" 4) #(1))))

(asin (#(procedure #:clean #:enforce #:foldable) asin (number) (or float cplxnum))
      ;; Unfortunately this doesn't work when the number is > 1.0 (returns compnum)
      #;((float) (float) (##core#inline_allocate ("C_a_i_flonum_acos" 4) #(1))))

(acos (#(procedure #:clean #:enforce #:foldable) acos (number) (or float cplxnum))
      ;; Unfortunately this doesn't work when the number is > 1.0 (returns compnum)
      #;((float) (float) (##core#inline_allocate ("C_a_i_flonum_acos" 4) #(1))))

(atan (#(procedure #:clean #:enforce #:foldable) atan (number #!optional number) (or float cplxnum))
      ((float) (float) (##core#inline_allocate ("C_a_i_flonum_atan" 4) #(1)))
      ((float float) (float)
       (##core#inline_allocate ("C_a_i_flonum_atan2" 4) #(1) #(2))))

(number->string (#(procedure #:clean #:enforce) number->string (number #!optional fixnum) string)
		((fixnum fixnum) (##sys#fixnum->string #(1) #(2)))
		((fixnum) (##sys#fixnum->string #(1) '10))
		((integer fixnum) (##sys#integer->string #(1) #(2)))
		((integer) (##sys#integer->string #(1) '10))
		((float fixnum) (##sys#flonum->string #(1) #(2)))
		((float) (##sys#flonum->string #(1) '10))
		((* *) (##sys#number->string #(1) #(2)))
		((*) (##sys#number->string #(1) '10)))

(##sys#fixnum->string (#(procedure #:clean #:enforce) ##sys#fixnum->string (fixnum fixnum) string))
(##sys#integer->string (#(procedure #:clean #:enforce) ##sys#integer->string (integer fixnum) string))
(##sys#flonum->string (#(procedure #:clean #:enforce) ##sys#flonum->string (float fixnum) string))

(string->number (#(procedure #:clean #:enforce #:foldable) string->number (string #!optional fixnum)
		 (or number false)))

(char? (#(procedure #:pure #:predicate char) char? (*) boolean))

;; safe rewrites are already done by the optimizer
(char=? (#(procedure #:clean #:enforce #:foldable) char=? (char char) boolean)
        ((char char) (##core#inline "C_u_i_char_equalp" #(1) #(2))))
(char>? (#(procedure #:clean #:enforce #:foldable) char>? (char char) boolean)
        ((char char) (##core#inline "C_u_i_char_greaterp" #(1) #(2))))
(char<? (#(procedure #:clean #:enforce #:foldable) char<? (char char) boolean)
        ((char char) (##core#inline "C_u_i_char_lessp" #(1) #(2))))
(char>=? (#(procedure #:clean #:enforce #:foldable) char>=? (char char) boolean)
         ((char char) (##core#inline "C_u_i_char_greater_or_equal_p" #(1) #(2))))
(char<=? (#(procedure #:clean #:enforce #:foldable) char<=? (char char) boolean)
         ((char char) (##core#inline "C_u_i_char_less_or_equal_p" #(1) #(2))))

(char-ci=? (#(procedure #:clean #:enforce #:foldable) char-ci=? (char char) boolean))
(char-ci<? (#(procedure #:clean #:enforce #:foldable) char-ci<? (char char) boolean))
(char-ci>? (#(procedure #:clean #:enforce #:foldable) char-ci>? (char char) boolean))
(char-ci>=? (#(procedure #:clean #:enforce #:foldable) char-ci>=? (char char) boolean))
(char-ci<=? (#(procedure #:clean #:enforce #:foldable) char-ci<=? (char char) boolean))
(char-alphabetic? (#(procedure #:clean #:enforce #:foldable) char-alphabetic? (char) boolean))
(char-whitespace? (#(procedure #:clean #:enforce #:foldable) char-whitespace? (char) boolean))
(char-numeric? (#(procedure #:clean #:enforce #:foldable) char-numeric? (char) boolean))
(char-upper-case? (#(procedure #:clean #:enforce #:foldable) char-upper-case? (char) boolean))
(char-lower-case? (#(procedure #:clean #:enforce #:foldable) char-lower-case? (char) boolean))
(char-upcase (#(procedure #:clean #:enforce #:foldable) char-upcase (char) char))
(char-downcase (#(procedure #:clean #:enforce #:foldable) char-downcase (char) char))

(char->integer (#(procedure #:clean #:enforce #:foldable) char->integer (char) fixnum))
(integer->char (#(procedure #:clean #:enforce #:foldable) integer->char (fixnum) char))

(string? (#(procedure #:pure #:predicate string) string? (*) boolean))

(string=? (#(procedure #:clean #:enforce #:foldable) string=? (string string) boolean)
	  ((string string) (##core#inline "C_u_i_string_equal_p" #(1) #(2))))

(string>? (#(procedure #:clean #:enforce #:foldable) string>? (string string) boolean))
(string<? (#(procedure #:clean #:enforce #:foldable) string<? (string string) boolean))
(string>=? (#(procedure #:clean #:enforce #:foldable) string>=? (string string) boolean))
(string<=? (#(procedure #:clean #:enforce #:foldable) string<=? (string string) boolean))
(string-ci=? (#(procedure #:clean #:enforce #:foldable) string-ci=? (string string) boolean))
(string-ci<? (#(procedure #:clean #:enforce #:foldable) string-ci<? (string string) boolean))
(string-ci>? (#(procedure #:clean #:enforce #:foldable) string-ci>? (string string) boolean))
(string-ci>=? (#(procedure #:clean #:enforce #:foldable) string-ci>=? (string string) boolean))
(string-ci<=? (#(procedure #:clean #:enforce #:foldable) string-ci<=? (string string) boolean))

(make-string (#(procedure #:clean #:enforce) make-string (fixnum #!optional char) string)
	     ((fixnum char) (##sys#make-string #(1) #(2)))
	     ((fixnum) (##sys#make-string #(1) '#\space)))

(string-length (#(procedure #:clean #:enforce #:foldable) string-length (string) fixnum)
	       ((string) (##sys#size #(1))))

(string-ref (#(procedure #:clean #:enforce #:foldable) string-ref (string fixnum) char)
	    ((string fixnum) (##core#inline "C_i_string_ref" #(1) #(2))))

(string-set! (#(procedure #:enforce) string-set! (string fixnum char) undefined)
	     ((string fixnum char) (##core#inline "C_i_string_set" #(1) #(2) #(3))))

(string-append (#(procedure #:clean #:enforce) string-append (#!rest string) string)
	       ((string string) (##sys#string-append #(1) #(2))))

(string-copy (#(procedure #:clean #:enforce) string-copy (string) string))

(string->list (#(procedure #:clean #:enforce) string->list (string) (list-of char)))
(list->string (#(procedure #:clean #:enforce) list->string ((list-of char)) string))
(substring (#(procedure #:clean #:enforce) substring (string fixnum #!optional fixnum) string))
(string-fill! (#(procedure #:enforce) string-fill! (string char) string))
(string (#(procedure #:clean #:enforce) string (#!rest char) string))

(vector? (#(procedure #:pure #:predicate vector) vector? (*) boolean))

;; special-cased (see scrutinizer.scm)
(make-vector (forall (a) (#(procedure #:clean #:enforce) make-vector (fixnum #!optional a) 
			  (vector-of a))))

;; these are special cased (see scrutinizer.scm)
(vector-ref (forall (a) (#(procedure #:clean #:enforce #:foldable) vector-ref ((vector-of a) fixnum) a)))
(##sys#vector-ref (forall (a) (#(procedure #:clean #:enforce #:foldable) ##sys#vector-ref ((vector-of a) fixnum) a)))

;; special-cased (see scrutinizer.scm)
(vector-set! (#(procedure #:enforce) vector-set! (vector fixnum *) undefined))

;; special cased (see scrutinizer.scm)
(vector (#(procedure #:pure) vector (#!rest) vector))
(##sys#vector (#(procedure #:pure) ##sys#vector (#!rest) vector))

(vector-length (#(procedure #:clean #:enforce #:foldable) vector-length (vector) fixnum)
	       ((vector) (##sys#size #(1))))
(##sys#vector-length (#(procedure #:clean #:enforce #:foldable) ##sys#vector-length (vector) fixnum)
		     ((vector) (##sys#size #(1))))

(vector->list (forall (a) (#(procedure #:clean #:enforce) vector->list ((vector-of a)) (list-of a))))
(##sys#vector->list (forall (a) (#(procedure #:clean #:enforce) ##sys#vector->list ((vector-of a)) (list-of a))))
(list->vector (forall (a) (#(procedure #:clean #:enforce) list->vector ((list-of a)) (vector-of a))))
(##sys#list->vector (forall (a) (#(procedure #:clean #:enforce) ##sys#list->vector ((list-of a)) (vector-of a))))
(vector-fill! (#(procedure #:enforce) vector-fill! (vector *) undefined))

(procedure? (#(procedure #:pure #:predicate procedure) procedure? (*) boolean))

(vector-copy! (#(procedure #:enforce) vector-copy! (vector vector #!optional fixnum) undefined))

(map (forall (a b) (#(procedure #:enforce) map ((procedure (a #!rest) b) (list-of a) #!rest list) (list-of b))))

(for-each
 (forall (a) (#(procedure #:enforce) for-each ((procedure (a #!rest) . *) (list-of a) #!rest list) undefined)))

(apply (#(procedure #:enforce) apply (procedure #!rest) . *))
(##sys#apply (#(procedure #:enforce) ##sys#apply (procedure #!rest) . *))

(force (procedure force (*) . *)
       (((not (struct promise))) #(1)))

(call-with-current-continuation
 (#(procedure #:enforce) call-with-current-continuation ((procedure (procedure) . *)) . *))

(input-port? (#(procedure #:pure #:predicate (refine (input) port)) input-port? (*) boolean))
(output-port? (#(procedure #:pure #:predicate (refine (output) port)) output-port? (*) boolean))

(current-input-port
 (#(procedure #:clean #:enforce) current-input-port (#!optional input-port boolean boolean) input-port)
 (() ##sys#standard-input)
 (((refine (input) port))
  (let ((#(tmp1) #(1)))
    (let ((#(tmp2) (set! ##sys#standard-input #(tmp1))))
      #(tmp1)))))

(current-output-port
 (#(procedure #:clean #:enforce) current-output-port (#!optional output-port boolean boolean) output-port)
 (() ##sys#standard-output)
 (((refine (output) port))
  (let ((#(tmp1) #(1)))
    (let ((#(tmp2) (set! ##sys#standard-output #(tmp1))))
      #(tmp1)))))

(call-with-input-file
    (procedure call-with-input-file (string (procedure (input-port) . *) #!rest) . *))

(call-with-output-file
    (procedure call-with-output-file (string (procedure (output-port) . *) #!rest) . *))

(open-input-file (#(procedure #:clean #:enforce) open-input-file (string #!rest symbol) input-port))
(open-output-file (#(procedure #:clean #:enforce) open-output-file (string #!rest symbol) output-port))
(close-input-port (#(procedure #:enforce) close-input-port (input-port) undefined))
(close-output-port (#(procedure #:enforce) close-output-port (output-port) undefined))
(input-port-open? (#(procedure #:enforce) input-port-open? (input-port) boolean))
(output-port-open? (#(procedure #:enforce) output-port-open? (output-port) boolean))

(read (#(procedure #:enforce) read (#!optional input-port) *))

(eof-object? (#(procedure #:pure #:predicate eof) eof-object? (*) boolean))

(read-char (#(procedure #:enforce) read-char (#!optional input-port) (or eof char)))
(peek-char (#(procedure #:enforce) peek-char (#!optional input-port) (or eof char)))

(write (#(procedure #:enforce) write (* #!optional output-port) undefined))
(display (#(procedure #:enforce) display (* #!optional output-port) undefined))
(write-char (#(procedure #:enforce) write-char (char #!optional output-port) undefined))

;;XXX Yes, that would be nice, but the output-port may be closed
#;(##sys#write-char-0
 (#(procedure #:enforce) ##sys#write-char-0 (char output-port) undefined)
 ((char output-port)
   (let ((#(tmp) #(1)))
     ((##sys#slot (##sys#slot #(tmp) '2) '2) #(tmp) #(2)))))

(newline (#(procedure #:enforce) newline (#!optional output-port) undefined))

(with-input-from-file
    (#(procedure #:enforce) with-input-from-file (string (procedure () . *) #!rest symbol) . *))

(with-output-to-file
    (#(procedure #:enforce) with-output-to-file (string (procedure () . *) #!rest symbol) . *))

(dynamic-wind
    (#(procedure #:enforce) dynamic-wind ((procedure () . *) (procedure () . *) (procedure () . *)) . *))

(values (#(procedure #:clean) values (#!rest values) . *))
(##sys#values (#(procedure #:clean) ##sys#values (#!rest values) . *))

(call-with-values (#(procedure #:enforce) call-with-values ((procedure () . *) procedure) . *)
  (((procedure () *) *) (let ((#(tmp1) #(1)))
			  (let ((#(tmp2) #(2)))
			    (#(tmp2) (#(tmp1)))))))

(##sys#call-with-values
 (#(procedure #:enforce) ##sys#call-with-values ((procedure () . *) procedure) . *)
 (((procedure () *) *) (let ((#(tmp1) #(1)))
			 (let ((#(tmp2) #(2)))
			   (#(tmp2) (#(tmp1)))))))

(char-ready? (#(procedure #:enforce) char-ready? (#!optional input-port) boolean))

(real-part (#(procedure #:clean #:enforce #:foldable) real-part (number) (or integer float ratnum))
	   (((or fixnum float bignum ratnum)) #(1))
	   ((cplxnum) (##core#inline "C_u_i_cplxnum_real" #(1))))

(imag-part (#(procedure #:clean #:enforce #:foldable) imag-part (number) (or integer float ratnum))
	   (((or fixnum bignum ratnum)) (let ((#(tmp) #(1))) '0))
	   ((float) (let ((#(tmp) #(1))) '0.0))
	   ((cplxnum) (##core#inline "C_u_i_cplxnum_imag" #(1))))

(magnitude (#(procedure #:clean #:enforce #:foldable) magnitude (number) number)
	   ((fixnum) (integer) (##core#inline_allocate ("C_a_i_fixnum_abs" 5) #(1)))
	   ((integer) (##core#inline_allocate ("C_s_a_u_i_integer_abs" 5) #(1)))
	   ((float) (float) (##core#inline_allocate ("C_a_i_flonum_abs" 4) #(1)))
	   (((or fixnum float bignum ratnum))
	    (##core#inline_allocate ("C_s_a_i_abs" 7) #(1))))

(angle (#(procedure #:clean #:enforce #:foldable) angle (number) float)
       ((float) (##core#inline_allocate ("C_a_i_flonum_atan2" 4) '0.0 #(1)))
       ((fixnum) (##core#inline_allocate
                          ("C_a_i_flonum_atan2" 4)
                          '0.0
                          (##core#inline_allocate ("C_a_i_fix_to_flo" 4) #(1))))
       ((cplxnum)
	(let ((#(tmp) #(1)))
	  (##core#inline_allocate
	   ("C_a_i_flonum_atan2" 4)
	   (##core#inline_allocate ("C_a_i_exact_to_inexact" 11)
				   (##core#inline "C_u_i_cplxnum_imag" #(tmp)))
	   (##core#inline_allocate ("C_a_i_exact_to_inexact" 11)
				   (##core#inline "C_u_i_cplxnum_real" #(tmp)))))))

(numerator (#(procedure #:clean #:enforce #:foldable) numerator ((or float integer ratnum)) (or float integer))
	   ((fixnum) (fixnum) #(1))
	   ((bignum) (bignum) #(1))
	   ((integer) (integer) #(1))
	   ((ratnum) (integer) (##core#inline "C_u_i_ratnum_num" #(1))))

(denominator (#(procedure #:clean #:enforce #:foldable) denominator ((or float integer ratnum)) (or float integer))
	     ((integer) (fixnum) (let ((#(tmp) #(1))) '1))
	     ((ratnum) (integer) (##core#inline "C_u_i_ratnum_denom" #(1))))

;; eval

(chicken.eval#chicken-home (#(procedure #:clean) chicken.eval#chicken-home () string))
(chicken.eval#eval (procedure chicken.eval#eval (* #!optional (struct environment)) . *))
(chicken.eval#extension-information (#(procedure #:clean) chicken.eval#extension-information (symbol) *))
(chicken.eval#load (procedure chicken.eval#load (string #!optional (procedure (*) . *)) undefined))
(chicken.eval#load-extension (#(procedure #:enforce) chicken.eval#load-extension (symbol) undefined))
(chicken.eval#load-library (#(procedure #:enforce) chicken.eval#load-library (symbol #!optional string) undefined))
(chicken.eval#load-relative (#(procedure #:enforce) chicken.eval#load-relative (string #!optional (procedure (*) . *)) undefined))
(chicken.eval#load-verbose (#(procedure #:clean) chicken.eval#load-verbose (#!optional *) *))
(chicken.eval#provide (#(procedure #:clean #:enforce) chicken.eval#provide (#!rest symbol) undefined))
(chicken.eval#provided? (#(procedure #:clean #:enforce) chicken.eval#provided? (#!rest symbol) boolean))
(chicken.eval#repository-path (#(procedure #:clean) chicken.eval#repository-path (#!optional *) *))
(chicken.eval#require (#(procedure #:clean) chicken.eval#require (#!rest symbol) undefined))

(chicken.eval#scheme-report-environment
 (#(procedure #:clean #:enforce) chicken.eval#scheme-report-environment (#!optional fixnum) (struct environment)))

(chicken.eval#null-environment
 (#(procedure #:clean #:enforce) chicken.eval#null-environment (#!optional fixnum) (struct environment)))

(chicken.eval#interaction-environment
 (#(procedure #:clean) chicken.eval#interaction-environment () (struct environment)))


;; chicken

(abort (procedure abort (*) noreturn))
(##sys#abort (procedure abort (*) noreturn))

(add1 (#(procedure #:clean #:enforce #:foldable) add1 (number) number)
      ((fixnum) (integer)
       (##core#inline_allocate ("C_a_i_fixnum_plus" 5) #(1) '1))
      ((integer) (integer)
       (##core#inline_allocate ("C_s_a_u_i_integer_plus" 5) #(1) '1))
      ((float) (float) 
       (##core#inline_allocate ("C_a_i_flonum_plus" 4) #(1) '1.0))
      ((*) (number)
       (##core#inline_allocate ("C_s_a_i_plus" 29) #(1) '1)))

(argc+argv (#(procedure #:clean) argc+argv () fixnum pointer))
(argv (#(procedure #:clean) argv () (list-of string)))

(chicken.bitwise#integer-length
 (#(procedure #:clean #:enforce #:foldable) chicken.bitwise#integer-length (integer) fixnum)
		((fixnum) (##core#inline "C_i_fixnum_length" #(1)))
		((*) (##core#inline "C_i_integer_length" #(1))))

(chicken-bitwise#arithmetic-shift
 (#(procedure #:clean #:enforce #:foldable) chicken.bitwise#arithmetic-shift (integer fixnum) integer)
		((* *) (##core#inline_allocate ("C_s_a_i_arithmetic_shift" 5) #(1) #(2))))

(exact-integer-nth-root (#(procedure #:clean #:enforce #:foldable) exact-integer-nth-root (integer integer) integer integer)
		    ((integer integer) (##sys#exact-integer-nth-root/loc 'exact-integer-nth-root #(1) #(2))))

(exact-integer-sqrt (#(procedure #:clean #:enforce #:foldable) exact-integer-sqrt (integer) integer integer)
		    ((integer) (##sys#exact-integer-sqrt #(1))))

(fixnum? (#(procedure #:pure #:predicate fixnum) fixnum? (*) boolean))
(flonum? (#(procedure #:pure #:predicate float) flonum? (*) boolean))
(bignum? (#(procedure #:pure #:predicate bignum) bignum? (*) boolean))
(ratnum? (#(procedure #:pure #:predicate ratnum) ratnum? (*) boolean))
(cplxnum? (#(procedure #:pure #:predicate cplxnum) cplxnum? (*) boolean))

(chicken.bitwise#bit-set?
 (#(procedure #:clean #:enforce #:foldable) chicken.bitwise#bit-set? (integer integer) boolean)
	  ((fixnum fixnum) (##core#inline "C_i_fixnum_bit_setp" #(1) #(2)))
	  ((* *) (##core#inline "C_i_bit_setp" #(1) #(2))))

(chicken.bitwise#bitwise-and
 (#(procedure #:clean #:enforce #:foldable) chicken.bitwise#bitwise-and (#!rest integer) integer)
           (() '-1)
           ((fixnum) (fixnum) #(1))
           ((integer) #(1))
           ((fixnum fixnum) (fixnum) (##core#inline "C_u_fixnum_and" #(1) #(2)))
           ((* *) (##core#inline_allocate ("C_s_a_i_bitwise_and" 5) #(1) #(2))))

(chicken.bitwise#bitwise-ior
 (#(procedure #:clean #:enforce #:foldable) chicken.bitwise#bitwise-ior (#!rest integer) integer)
           (() '0)
           ((fixnum) (fixnum) #(1))
           ((integer) #(1))
           ((fixnum fixnum) (fixnum) (##core#inline "C_u_fixnum_or" #(1) #(2)))
	   ((* *) (##core#inline_allocate ("C_s_a_i_bitwise_ior" 5) #(1) #(2))))

(chicken.bitwise#bitwise-xor
 (#(procedure #:clean #:enforce #:foldable) chicken.bitwise#bitwise-xor (#!rest integer) integer)
           (() '0)
           ((fixnum) (fixnum) #(1))
           ((integer) #(1))
           ((fixnum fixnum) (fixnum) (##core#inline "C_fixnum_xor" #(1) #(2)))
           ((* *) (##core#inline_allocate ("C_s_a_i_bitwise_xor" 5) #(1) #(2))))

(chicken.bitwise#bitwise-not
 (#(procedure #:clean #:enforce #:foldable) chicken.bitwise#bitwise-not (integer) integer)
	     ((* *) (##core#inline_allocate ("C_s_a_i_bitwise_not" 5) #(1))))

(blob->string (#(procedure #:clean #:enforce) blob->string (blob) string))

(blob-size (#(procedure #:clean #:enforce #:foldable) blob-size (blob) fixnum)
	   ((blob) (##sys#size #(1))))

(blob? (#(procedure #:pure #:predicate blob) blob? (*) boolean))

(blob=? (#(procedure #:clean #:enforce #:foldable) blob=? (blob blob) boolean))
(build-platform (#(procedure #:pure) build-platform () symbol))
(call/cc (#(procedure #:enforce) call/cc ((procedure (*) . *)) . *))
(case-sensitive (#(procedure #:clean) case-sensitive (#!optional *) *))
(char-name (#(procedure #:clean #:enforce) char-name ((or char symbol) #!optional char) *)) ;XXX -> (or char symbol) ?
(chicken-version (#(procedure #:pure) chicken-version (#!optional *) string))
(command-line-arguments (#(procedure #:clean) command-line-arguments (#!optional (list-of string)) (list-of string)))
(condition-predicate (#(procedure #:clean #:enforce) condition-predicate (symbol) (procedure ((struct condition)) boolean)))
(condition-property-accessor (#(procedure #:clean #:enforce) condition-property-accessor (symbol symbol #!optional *) (procedure ((struct condition)) *)))

(condition? (#(procedure #:pure #:predicate (struct condition)) condition? (*) boolean))

(condition->list (#(procedure #:clean #:enforce) condition->list ((struct condition)) (list-of (pair symbol *))))

;; continuation

(chicken.continuation#continuation-capture (#(procedure #:enforce) chicken.continuation#continuation-capture ((procedure ((struct continuation)) . *)) *))
(chicken.continuation#continuation-graft (#(procedure #:clean #:enforce) chicken.continuation#continuation-graft ((struct continuation) (procedure () . *)) *))
(chicken.continuation#continuation-return (#(procedure #:enforce) chicken.continuation#continuation-return ((struct continuation) #!rest) . *)) ;XXX make return type more specific?
(chicken.continuation#continuation? (#(procedure #:pure #:predicate (struct continuation)) chicken.continuation#continuation? (*) boolean))

;; read-syntax

(chicken.read-syntax#copy-read-table (#(procedure #:clean #:enforce) chicken.read-syntax#copy-read-table ((struct read-table)) (struct read-table)))
(chicken.read-syntax#define-reader-ctor (#(procedure #:clean #:enforce) chicken.read-syntax#define-reader-ctor (symbol procedure) undefined))

(chicken.read-syntax#set-parameterized-read-syntax!
 (#(procedure #:clean #:enforce) chicken.read-syntax#set-parameterized-read-syntax!
  (char (or false (procedure (input-port fixnum) . *)))
  undefined))

(chicken.read-syntax#set-read-syntax!
 (#(procedure #:clean #:enforce) chicken.read-syntax#set-read-syntax!
  ((or char symbol) (or false (procedure (input-port) . *)))
  undefined))

(chicken.read-syntax#set-sharp-read-syntax!
 (#(procedure #:clean #:enforce) chicken.read-syntax#set-sharp-read-syntax!
  (char (or false (procedure (input-port) . *))) undefined))

(current-error-port
 (#(procedure #:clean #:enforce) current-error-port (#!optional output-port boolean boolean) output-port)
 ((output-port) (let ((#(tmp1) #(1))) 
		  (let ((#(tmp2) (set! ##sys#standard-error #(tmp1))))
		    #(tmp1))))
 (() ##sys#standard-error))

(current-exception-handler
 (#(procedure #:clean #:enforce) current-exception-handler (#!optional (procedure (*) noreturn) boolean boolean) procedure)
 ((procedure) (let ((#(tmp1) #(1))) 
		(let ((#(tmp2) (set! ##sys#current-exception-handler #(tmp1))))
		  #(tmp1))))
 (() ##sys#current-exception-handler))

;; time

(chicken.time#cpu-time (#(procedure #:clean) chicken.time#cpu-time () fixnum fixnum))
(chicken.time#current-seconds (#(procedure #:clean) chicken.time#current-seconds () integer))
(chicken.time#current-milliseconds (#(procedure #:clean) chicken.time#current-milliseconds () integer))

(current-read-table
 (#(procedure #:clean) current-read-table (#!optional (struct read-table)) (struct read-table)))

(delete-file (#(procedure #:clean #:enforce) delete-file (string) string))
(enable-warnings (#(procedure #:clean) enable-warnings (#!optional *) *))

(equal=? (#(procedure #:clean #:foldable) equal=? (* *) boolean)
	 ((fixnum fixnum) (eq? #(1) #(2)))
	 (((or symbol char eof null undefined) *) (eq? #(1) #(2)))
	 ((* (or symbol char eof null undefined)) (eq? #(1) #(2)))
	 ((number number) (= #(1) #(2))))

(chicken.expand#er-macro-transformer
 (#(procedure #:clean #:enforce) 
  chicken.expand#er-macro-transformer
  ((procedure (* (procedure (*) *) (procedure (* *) *)) *))
  (struct transformer)))

(errno (#(procedure #:clean) errno () fixnum))
(error (procedure error (* #!rest) noreturn))
(##sys#error (procedure ##sys#error (* #!rest) noreturn))
(##sys#signal-hook (procedure ##sys#signal-hook (* #!rest) noreturn))
(##sys#debug-mode? (procedure ##sys#debug-mode? () boolean)
		   (() (##core#inline "C_i_debug_modep")))
(executable-pathname (#(procedure #:pure) executable-pathname () (or string false)))
(exit (procedure exit (#!optional fixnum) noreturn))
(exit-handler (#(procedure #:clean #:enforce) exit-handler (#!optional (procedure (fixnum) . *)) procedure))
(chicken.expand#expand (procedure chicken.expand#expand (* #!optional list) *))
(feature? (#(procedure #:clean) feature? (#!rest symbol) boolean))
(features (#(procedure #:clean) features () (list-of symbol)))
(file-exists? (#(procedure #:clean #:enforce) file-exists? (string) (or false string)))
(directory-exists? (#(procedure #:clean #:enforce) directory-exists? (string) (or false string)))

(flush-output (#(procedure #:enforce) flush-output (#!optional output-port) undefined))

(foldl (forall (a b) (#(procedure #:enforce) foldl ((procedure (a b) a) a (list-of b)) a)))
(foldr (forall (a b) (#(procedure #:enforce) foldr ((procedure (a b) b) b (list-of a)) b)))

(force-finalizers (procedure force-finalizers () undefined))

(nan? (#(procedure #:clean #:enforce #:foldable) nan? (number) boolean)
      (((or integer ratnum)) (let ((#(tmp) #(1))) '#f))
      ((float) (##core#inline "C_u_i_flonum_nanp" #(1)))
      ((*) (##core#inline "C_i_nanp" #(1))))

(infinite? (#(procedure #:clean #:enforce #:foldable) infinite? (number) boolean)
	   (((or integer ratnum)) (let ((#(tmp) #(1))) '#f))
	   ((float) (##core#inline "C_u_i_flonum_infinitep" #(1)))
	   ((*) (##core#inline "C_i_infinitep" #(1))))

(finite? (#(procedure #:clean #:enforce #:foldable) finite? (number) boolean)
	 (((or integer ratnum)) (let ((#(tmp) #(1))) '#t))
	 ((float) (##core#inline "C_u_i_flonum_finitep" #(1)))
	 ((*) (##core#inline "C_i_finitep" #(1))))

;; flonum

(chicken.flonum#flonum-decimal-precision fixnum)
(chicken.flonum#flonum-epsilon float)
(chicken.flonum#flonum-maximum-decimal-exponent fixnum)
(chicken.flonum#flonum-maximum-exponent fixnum)
(chicken.flonum#flonum-minimum-decimal-exponent fixnum)
(chicken.flonum#flonum-minimum-exponent fixnum)
(chicken.flonum#flonum-precision fixnum)
(chicken.flonum#flonum-print-precision (#(procedure #:clean #:enforce) chicken.flonum#flonum-print-precision (#!optional fixnum) fixnum))
(chicken.flonum#flonum-radix fixnum)

(chicken.flonum#fp- (#(procedure #:clean #:enforce #:foldable) chicken.flonum#fp- (float float) float)
     ((float float) (##core#inline_allocate ("C_a_i_flonum_difference" 4) #(1) #(2)) ))

(chicken.flonum#fp* (#(procedure #:clean #:enforce #:foldable) chicken.flonum#fp* (float float) float)
     ((float float) (##core#inline_allocate ("C_a_i_flonum_times" 4) #(1) #(2)) ))

(chicken.flonum#fp/ (#(procedure #:clean #:enforce #:foldable) chicken.flonum#fp/ (float float) float)
     ((float float) (##core#inline_allocate ("C_a_i_flonum_quotient" 4) #(1) #(2)) ))

(chicken.flonum#fpgcd (#(procedure #:clean #:enforce #:foldable) chicken.flonum#fpgcd (float float) float)
       ((float float) (##core#inline_allocate ("C_a_i_flonum_gcd" 4) #(1) #(2)) ))

(chicken.flonum#fp+ (#(procedure #:clean #:enforce #:foldable) chicken.flonum#fp+ (float float) float)
     ((float float) (##core#inline_allocate ("C_a_i_flonum_plus" 4) #(1) #(2)) ))

(chicken.flonum#fp< (#(procedure #:clean #:enforce #:foldable) chicken.flonum#fp< (float float) boolean)
     ((float float) (##core#inline "C_flonum_lessp" #(1) #(2)) ))

(chicken.flonum#fp<= (#(procedure #:clean #:enforce #:foldable) chicken.flonum#fp<= (float float) boolean)
      ((float float) (##core#inline "C_flonum_less_or_equal_p" #(1) #(2)) ))

(chicken.flonum#fp= (#(procedure #:clean #:enforce #:foldable) chicken.flonum#fp= (float float) boolean)
     ((float float) (##core#inline "C_flonum_equalp" #(1) #(2)) ))

(chicken.flonum#fp> (#(procedure #:clean #:enforce #:foldable) chicken.flonum#fp> (float float) boolean)
     ((float float) (##core#inline "C_flonum_greaterp" #(1) #(2)) ))

(chicken.flonum#fp>= (#(procedure #:clean #:enforce #:foldable) chicken.flonum#fp>= (float float) boolean)
      ((float float) (##core#inline "C_flonum_greater_or_equal_p" #(1) #(2)) ))

(chicken.flonum#fpabs (#(procedure #:clean #:enforce #:foldable) chicken.flonum#fpabs (float) float)
       ((float) (##core#inline_allocate ("C_a_i_flonum_abs" 4) #(1) )))

(chicken.flonum#fpacos (#(procedure #:clean #:enforce #:foldable) chicken.flonum#fpacos (float) float)
       ((float) (##core#inline_allocate ("C_a_i_flonum_acos" 4) #(1) )))

(chicken.flonum#fpasin (#(procedure #:clean #:enforce #:foldable) chicken.flonum#fpasin (float) float)
	((float) (##core#inline_allocate ("C_a_i_flonum_asin" 4) #(1) )))

(chicken.flonum#fpatan (#(procedure #:clean #:enforce #:foldable) chicken.flonum#fpatan (float) float)
	((float) (##core#inline_allocate ("C_a_i_flonum_atan" 4) #(1) )))

(chicken.flonum#fpatan2 (#(procedure #:clean #:enforce #:foldable) chicken.flonum#fpatan2 (float float) float)
	 ((float float) (##core#inline_allocate ("C_a_i_flonum_atan2" 4) #(1) #(2))))

(chicken.flonum#fpceiling (#(procedure #:clean #:enforce #:foldable) chicken.flonum#fpceiling (float) float)
	   ((float) (##core#inline_allocate ("C_a_i_flonum_ceiling" 4) #(1) )))

(chicken.flonum#fpcos (#(procedure #:clean #:enforce #:foldable) chicken.flonum#fpcos (float) float)
       ((float) (##core#inline_allocate ("C_a_i_flonum_cos" 4) #(1) )))

(chicken.flonum#fpexp (#(procedure #:clean #:enforce #:foldable) chicken.flonum#fpexp (float) float)
       ((float) (##core#inline_allocate ("C_a_i_flonum_exp" 4) #(1) )))

(chicken.flonum#fpexpt (#(procedure #:clean #:enforce #:foldable) chicken.flonum#fpexpt (float float) float)
	((float float) (##core#inline_allocate ("C_a_i_flonum_expt" 4) #(1) #(2))))

(chicken.flonum#fpfloor (#(procedure #:clean #:enforce #:foldable) chicken.flonum#fpfloor (float) float)
	 ((float) (##core#inline_allocate ("C_a_i_flonum_floor" 4) #(1) )))

(chicken.flonum#fpinteger? (#(procedure #:clean #:enforce #:foldable) chicken.flonum#fpinteger? (float) boolean)
	    ((float) (##core#inline "C_u_i_fpintegerp" #(1) )))

(chicken.flonum#fplog (#(procedure #:clean #:enforce #:foldable) chicken.flonum#fplog (float) float)
       ((float) (##core#inline_allocate ("C_a_i_flonum_log" 4) #(1) )))

(chicken.flonum#fpmax (#(procedure #:clean #:enforce #:foldable) chicken.flonum#fpmax (float float) float)
       ((float float) (##core#inline "C_i_flonum_max" #(1) #(2))))

(chicken.flonum#fpmin (#(procedure #:clean #:enforce #:foldable) chicken.flonum#fpmin (float float) float)
       ((float float) (##core#inline "C_i_flonum_min" #(1) #(2))))

(chicken.flonum#fpneg (#(procedure #:clean #:enforce #:foldable) chicken.flonum#fpneg (float) float)
       ((float) (##core#inline_allocate ("C_a_i_flonum_negate" 4) #(1) )))

(chicken.flonum#fpround (#(procedure #:clean #:enforce #:foldable) chicken.flonum#fpround (float) float)
	 ((float) (##core#inline_allocate ("C_a_i_flonum_round" 4) #(1) )))

(chicken.flonum#fpsin (#(procedure #:clean #:enforce #:foldable) chicken.flonum#fpsin (float) float)
       ((float) (##core#inline_allocate ("C_a_i_flonum_sin" 4) #(1) )))

(chicken.flonum#fpsqrt (#(procedure #:clean #:enforce #:foldable) chicken.flonum#fpsqrt (float) float)
	((float) (##core#inline_allocate ("C_a_i_flonum_sqrt" 4) #(1) )))

(chicken.flonum#fptan (#(procedure #:clean #:enforce #:foldable) chicken.flonum#fptan (float) float)
       ((float) (##core#inline_allocate ("C_a_i_flonum_tan" 4) #(1) )))

(chicken.flonum#fptruncate (#(procedure #:clean #:enforce #:foldable) chicken.flonum#fptruncate (float) float)
	    ((float) (##core#inline_allocate ("C_a_i_flonum_truncate" 4) #(1) )))

;; fixnum

(chicken.fixnum#fixnum-bits fixnum)
(chicken.fixnum#fixnum-precision fixnum)

;;XXX should these be enforcing?
(chicken.fixnum#fx- (#(procedure #:clean #:foldable) chicken.fixnum#fx- (fixnum fixnum) fixnum))
(chicken.fixnum#fx* (#(procedure #:clean #:foldable) chicken.fixnum#fx* (fixnum fixnum) fixnum))
(chicken.fixnum#fx/ (#(procedure #:clean #:foldable) chicken.fixnum#fx/ (fixnum fixnum) fixnum))
(chicken.fixnum#fxgcd (#(procedure #:clean #:foldable) chicken.fixnum#fxgcd (fixnum fixnum) fixnum))
(chicken.fixnum#fx+ (#(procedure #:clean #:foldable) chicken.fixnum#fx+ (fixnum fixnum) fixnum))
(chicken.fixnum#fx< (#(procedure #:clean #:foldable) chicken.fixnum#fx< (fixnum fixnum) boolean))
(chicken.fixnum#fx<= (#(procedure #:clean #:foldable) chicken.fixnum#fx<= (fixnum fixnum) boolean))
(chicken.fixnum#fx= (#(procedure #:clean #:foldable) chicken.fixnum#fx= (fixnum fixnum) boolean))
(chicken.fixnum#fx> (#(procedure #:clean #:foldable) chicken.fixnum#fx> (fixnum fixnum) boolean))
(chicken.fixnum#fx>= (#(procedure #:clean #:foldable) chicken.fixnum#fx>= (fixnum fixnum) boolean))
(chicken.fixnum#fxand (#(procedure #:clean #:foldable) chicken.fixnum#fxand (fixnum fixnum) fixnum))
(chicken.fixnum#fxeven? (#(procedure #:clean #:foldable) chicken.fixnum#fxeven? (fixnum) boolean))
(chicken.fixnum#fxior (#(procedure #:clean #:foldable) chicken.fixnum#fxior (fixnum fixnum) fixnum))
(chicken.fixnum#fxmax (#(procedure #:clean #:foldable) chicken.fixnum#fxmax (fixnum fixnum) fixnum))
(chicken.fixnum#fxmin (#(procedure #:clean #:foldable) chicken.fixnum#fxmin (fixnum fixnum) fixnum))
(chicken.fixnum#fxmod (#(procedure #:clean #:foldable) chicken.fixnum#fxmod (fixnum fixnum) fixnum))
(chicken.fixnum#fxrem (#(procedure #:clean #:foldable) chicken.fixnum#fxrem (fixnum fixnum) fixnum))
(chicken.fixnum#fxneg (#(procedure #:clean #:foldable) chicken.fixnum#fxneg (fixnum) fixnum))
(chicken.fixnum#fxnot (#(procedure #:clean #:foldable) chicken.fixnum#fxnot (fixnum) fixnum))
(chicken.fixnum#fxodd? (#(procedure #:clean #:foldable) chicken.fixnum#fxodd? (fixnum) boolean))
(chicken.fixnum#fxshl (#(procedure #:clean #:foldable) chicken.fixnum#fxshl (fixnum fixnum) fixnum))
(chicken.fixnum#fxshr (#(procedure #:clean #:foldable) chicken.fixnum#fxshr (fixnum fixnum) fixnum))
(chicken.fixnum#fxxor (#(procedure #:clean #:foldable) chicken.fixnum#fxxor (fixnum fixnum) fixnum))
(chicken.fixnum#fxlen (#(procedure #:clean #:foldable) chicken.fixnum#fxlen (fixnum) fixnum))

(gensym (#(procedure #:clean) gensym (#!optional (or string symbol)) symbol))

(get (#(procedure #:clean #:enforce) get (symbol symbol #!optional *) *)
     ((symbol symbol *) (##core#inline "C_i_getprop" #(1) #(2) #(3))))

(get-call-chain (#(procedure #:clean #:enforce) get-call-chain (#!optional fixnum (struct thread)) (list-of vector)))
(get-condition-property (#(procedure #:clean #:enforce) get-condition-property ((struct condition) symbol symbol #!optional *) *))
(get-environment-variable (#(procedure #:clean #:enforce) get-environment-variable (string) *))
(get-output-string (#(procedure #:clean #:enforce) get-output-string (output-port) string))
(get-properties (#(procedure #:clean #:enforce) get-properties (symbol list) symbol * list))

;; keyword

(chicken.keyword#get-keyword (#(procedure #:clean #:enforce) chicken.keyword#get-keyword (symbol list #!optional *) *))
(chicken.keyword#keyword->string (#(procedure #:clean #:enforce) chicken.keyword#keyword->string (symbol) string))
(chicken.keyword#keyword? (#(procedure #:pure) chicken.keyword#keyword? (*) boolean))
(chicken.keyword#string->keyword (#(procedure #:clean #:enforce) chicken.keyword#string->keyword (string) symbol))

(getter-with-setter
 (#(procedure #:clean #:enforce)
  getter-with-setter
  ((procedure (#!rest) *) (procedure (* #!rest) . *) #!optional string)
  procedure))

(implicit-exit-handler
 (#(procedure #:clean #:enforce) implicit-exit-handler (#!optional (procedure () . *)) procedure))

(chicken.expand#ir-macro-transformer
 (#(procedure #:clean #:enforce)
  chicken.expand#ir-macro-transformer
  ((procedure (* (procedure (*) *) (procedure (* *) *)) *))
  (struct transformer)))

(keyword-style (#(procedure #:clean) keyword-style (#!optional symbol) symbol))
(machine-byte-order (#(procedure #:pure) machine-byte-order () symbol))
(machine-type (#(procedure #:pure) machine-type () symbol))

(make-blob (#(procedure #:clean #:enforce) make-blob (fixnum) blob)
	   ((fixnum) (##sys#make-blob #(1))))

(make-composite-condition (#(procedure #:clean #:enforce) make-composite-condition (#!rest (struct condition)) (struct condition)))
(make-parameter (#(procedure #:clean #:enforce) make-parameter (* #!optional procedure) procedure))
(make-property-condition (#(procedure #:clean #:enforce) make-property-condition (symbol #!rest *) (struct condition)))
(chicken.flonum#maximum-flonum float)
(chicken.flonum#minimum-flonum float)
(chicken.fixnum#most-negative-fixnum fixnum)
(chicken.fixnum#most-positive-fixnum fixnum)
(module-environment (#(procedure #:clean #:enforce) module-environment ((or symbol (list-of (or symbol fixnum))) #!optional *) (struct environment)))
(on-exit (#(procedure #:clean #:enforce) on-exit ((procedure () . *)) undefined))
(open-input-string (#(procedure #:clean #:enforce) open-input-string (string #!rest) input-port))
(open-output-string (#(procedure #:clean) open-output-string (#!rest) output-port))
(parentheses-synonyms (#(procedure #:clean) parentheses-synonyms (#!optional *) *))

(port-name (#(procedure #:clean #:enforce) port-name (#!optional port) *)
	   ((port) (##sys#slot #(1) '3)))

(port-position (#(procedure #:clean #:enforce) port-position (#!optional port) fixnum fixnum))

(port? (#(procedure #:pure #:predicate port) port? (*) boolean))

(port-closed? (#(procedure #:clean #:enforce) port-closed? (port) boolean)
	      ((port) (eq? (##sys#slot #(1) '8) '0)))

(print (procedure print (#!rest *) undefined))
(print-call-chain (#(procedure #:clean #:enforce) print-call-chain (#!optional output-port fixnum * string) undefined))
(print-error-message (#(procedure #:clean #:enforce) print-error-message (* #!optional output-port string) undefined))
(print* (procedure print* (#!rest) undefined))
(procedure-information (#(procedure #:clean #:enforce) procedure-information (procedure) *))
(program-name (#(procedure #:clean #:enforce) program-name (#!optional string) string))
(promise? (#(procedure #:pure #:predicate (struct promise)) promise? (*) boolean))

(make-promise (#(procedure #:enforce) make-promise (*) (struct promise))
              (((struct promise)) #(1)))

(put! (#(procedure #:clean #:enforce) put! (symbol symbol *) undefined)
      ((symbol symbol *)
       (##core#inline_allocate ("C_a_i_putprop" 8) #(1) #(2) #(3))))

(quit (procedure quit (#!optional *) noreturn))

(register-feature! (#(procedure #:clean #:enforce) register-feature! (#!rest symbol) undefined))
(remprop! (#(procedure #:clean #:enforce) remprop! (symbol symbol) undefined))
(rename-file (#(procedure #:clean #:enforce) rename-file (string string) string))
(reset (procedure reset () noreturn))
(reset-handler (#(procedure #:clean #:enforce) reset-handler (#!optional (procedure () . *)) procedure))
(return-to-host (procedure return-to-host () . *))
(reverse-list->string (#(procedure #:clean #:enforce) reverse-list->string ((list-of char)) string))

;; gc

(chicken.gc#current-gc-milliseconds (#(procedure #:clean) chicken.gc#current-gc-milliseconds () integer))
(chicken.gc#gc (#(procedure #:clean) chicken.gc#gc (#!optional *) fixnum))
(chicken.gc#memory-statistics (#(procedure #:clean) chicken.gc#memory-statistics () (vector-of fixnum)))
(chicken.gc#set-finalizer! (#(procedure #:clean #:enforce) chicken.gc#set-finalizer! (* (procedure (*) . *)) *))
(chicken.gc#set-gc-report! (#(procedure #:clean) chicken.gc#set-gc-report! (*) undefined))

(chicken.repl#repl (#(procedure #:enforce) chicken.repl#repl (#!optional (procedure (*) . *)) undefined))
(chicken.repl#repl-prompt (#(procedure #:clean #:enforce) chicken.repl#repl-prompt (#!optional (procedure () string)) procedure))

(set-port-name! (#(procedure #:clean #:enforce) set-port-name! (port string) undefined)
		((port string) (##sys#setslot #(1) '3 #(2))))

(setter (#(procedure #:clean #:enforce) setter (procedure) procedure))
(signal (procedure signal (*) . *))

(signum (#(procedure #:clean #:enforce) signum (number) (or fixnum float cplxnum))
	((fixnum) (fixnum) (##core#inline "C_i_fixnum_signum" #(1)))
	((integer) (fixnum) (##core#inline "C_u_i_integer_signum" #(1)))
	((float) (float)
	 (##core#inline_allocate ("C_a_u_i_flonum_signum" 4) #(1)))
	((ratnum) (fixnum)
	 (##core#inline "C_u_i_integer_signum"
			(##core#inline "C_u_i_ratnum_num" #(1))))
	((cplxnum) ((or float cplxnum)) (##sys#extended-signum #(1))))

(sleep (#(procedure #:clean #:enforce) sleep (fixnum) undefined))
(software-type (#(procedure #:pure) software-type () symbol))
(software-version (#(procedure #:pure) software-version () symbol))
(string->blob (#(procedure #:clean #:enforce) string->blob (string) blob))
(string->uninterned-symbol (#(procedure #:clean #:enforce) string->uninterned-symbol (string) symbol))
(chicken.expand#strip-syntax (#(procedure #:clean) chicken.expand#strip-syntax (*) *))

(sub1 (#(procedure #:clean #:enforce #:foldable) sub1 (number) number)
      ((fixnum) (integer)
       (##core#inline_allocate ("C_a_i_fixnum_difference" 5) #(1) '1))
      ((integer) (integer)
       (##core#inline_allocate ("C_s_a_u_i_integer_minus" 5) #(1) '1))
      ((float) (float) 
       (##core#inline_allocate ("C_a_i_flonum_difference" 4) #(1) '1.0))
      ((*) (number)
       (##core#inline_allocate ("C_s_a_i_minus" 29) #(1) '1)))

(subvector (forall (a) (#(procedure #:clean #:enforce) subvector ((vector-of a) fixnum #!optional fixnum) (vector-of a))))
(symbol-escape (#(procedure #:clean) symbol-escape (#!optional *) *))

(symbol-plist (#(procedure #:clean #:enforce) symbol-plist (symbol) list)
	      ((symbol) (##sys#slot #(1) '2)))

(chicken.expand#syntax-error (procedure chicken.expand#syntax-error (* #!rest) noreturn))
(system (#(procedure #:clean #:enforce) system (string) fixnum))
(unregister-feature! (#(procedure #:clean #:enforce) unregister-feature! (#!rest symbol) undefined))
(vector-resize
 (forall (a b) (#(procedure #:clean #:enforce) vector-resize ((vector-of a) fixnum #!optional b)
	       (vector-of (or a b)))))
(void (#(procedure #:pure) void (#!rest) undefined))
(##sys#void (#(procedure #:pure) void (#!rest) undefined))
(warning (procedure warning (* #!rest) undefined))

(with-exception-handler
 (#(procedure #:enforce) with-exception-handler ((procedure (*) . *) (procedure () . *)) . *))

;; chicken (internal)

(##sys#foreign-char-argument (#(procedure #:clean #:enforce) ##sys#foreign-char-argument (char) char)
			     ((char) #(1)))
(##sys#foreign-fixnum-argument (#(procedure #:clean #:enforce) ##sys#foreign-fixnum-argument (fixnum) fixnum)
			       ((fixnum) #(1)))
(##sys#foreign-flonum-argument (#(procedure #:clean #:enforce) ##sys#foreign-flonum-argument (number) number)
			       ((float) #(1)))
(##sys#foreign-string-argument (#(procedure #:clean #:enforce) ##sys#foreign-string-argument (string) string)
			       ((string) #(1)))
(##sys#foreign-symbol-argument (#(procedure #:clean #:enforce) ##sys#foreign-symbol-argument (symbol) symbol)
			       ((symbol) #(1)))
(##sys#foreign-pointer-argument (#(procedure #:clean #:enforce) ##sys#foreign-pointer-argument ((or pointer false)) pointer)
				((pointer) #(1)))

(##sys#check-blob (#(procedure #:clean #:enforce) ##sys#check-blob (blob #!optional *) *)
		  ((blob) (let ((#(tmp) #(1))) '#t))
		  ((blob *) (let ((#(tmp) #(1))) '#t)))
(##sys#check-pair (#(procedure #:clean #:enforce) ##sys#check-pair (pair #!optional *) *)
		  ((pair) (let ((#(tmp) #(1))) '#t))
		  ((pair *) (let ((#(tmp) #(1))) '#t)))
(##sys#check-list (#(procedure #:clean #:enforce) ##sys#check-list (list #!optional *) *)
		  (((or null pair list)) (let ((#(tmp) #(1))) '#t))
		  (((or null pair list) *) (let ((#(tmp) #(1))) '#t)))
(##sys#check-string (#(procedure #:clean #:enforce) ##sys#check-string (string #!optional *) *)
		    ((string) (let ((#(tmp) #(1))) '#t))
		    ((string) * (let ((#(tmp) #(1))) '#t)))
(##sys#check-number (#(procedure #:clean #:enforce) ##sys#check-number (number #!optional *) *)
		    ((number) (let ((#(tmp) #(1))) '#t))
		    ((number *) (let ((#(tmp) #(1))) '#t)))
(##sys#check-exact (#(procedure #:clean #:enforce) ##sys#check-exact (fixnum #!optional *) *)
		   ((fixnum) (let ((#(tmp) #(1))) '#t))
		   ((fixnum *) (let ((#(tmp) #(1))) '#t)))
(##sys#check-inexact (#(procedure #:clean #:enforce) ##sys#check-inexact (float #!optional *) *)
		     ((float) (let ((#(tmp) #(1))) '#t))
		     ((float *) (let ((#(tmp) #(1))) '#t)))
(##sys#check-symbol (#(procedure #:clean #:enforce) ##sys#check-symbol (symbol #!optional *) *)
		    ((symbol) (let ((#(tmp) #(1))) '#t))
		    ((symbol *) (let ((#(tmp) #(1))) '#t)))
(##sys#check-vector (#(procedure #:clean #:enforce) ##sys#check-vector (vector #!optional *) *)
		    ((vector) (let ((#(tmp) #(1))) '#t))
		    ((vector *) (let ((#(tmp) #(1))) '#t)))
(##sys#check-char (#(procedure #:clean #:enforce) ##sys#check-char (char #!optional *) *)
		  ((char) (let ((#(tmp) #(1))) '#t))
		  ((char *) (let ((#(tmp) #(1))) '#t)))
(##sys#check-boolean (#(procedure #:clean #:enforce) ##sys#check-boolean (boolean #!optional *) *)
		     ((boolean) (let ((#(tmp) #(1))) '#t))
		     ((boolean *) (let ((#(tmp) #(1))) '#t)))
(##sys#check-locative (#(procedure #:clean #:enforce) ##sys#check-locative (locative #!optional *) *)
		      ((locative) (let ((#(tmp) #(1))) '#t))
		      ((locative *) (let ((#(tmp) #(1))) '#t)))
(##sys#check-closure (#(procedure #:clean #:enforce) ##sys#check-closure (procedure #!optional *) *)
		     ((procedure) (let ((#(tmp) #(1))) '#t))
		     ((procedure *) (let ((#(tmp) #(1))) '#t)))

(##sys#check-port 
 (#(procedure #:clean #:enforce) ##sys#check-port ((or input-port output-port) #!optional *) *)
 (((or (refine (input) port) (refine (output) port))) (let ((#(tmp) #(1))) '#t))
 (((or (refine (input) port) (refine (output) port)) *) (let ((#(tmp) #(1))) '#t)))

(##sys#check-input-port
 (#(procedure #:clean #:enforce) ##sys#check-input-port (input-port * #!optional *) *)
 ((* *) (##core#inline "C_i_check_port" #(1) '1 #(2)))
 ((* * *) (##core#inline "C_i_check_port_2" #(1) '1 #(2) #(3))))

(##sys#check-output-port
 (#(procedure #:clean #:enforce) ##sys#check-output-port (output-port * #!optional *) *)
 ((* *) (##core#inline "C_i_check_port" #(1) '2 #(2)))
 ((* * *) (##core#inline "C_i_check_port_2" #(1) '2 #(2) #(3))))

(##sys#check-open-port
 (#(procedure #:clean #:enforce) ##sys#check-open-port ((or input-port output-port) #!optional *) *)
 ((*) (##core#inline "C_i_check_port" #(1) '0 '#t))
 ((* *) (##core#inline "C_i_check_port_2" #(1) '0 '#t #(2))))

(##sys#slot (#(procedure #:enforce) ##sys#slot (* fixnum) *))

(##sys#setslot (#(procedure #:enforce) ##sys#setslot (* fixnum *) *)
	       #;((* fixnum immediate) (##sys#setislot #(1) #(2) #(3)))) ; too dangerous

(##sys#size (#(procedure #:pure #:foldable) ##sys#size (*) fixnum))

(##sys#standard-input input-port)
(##sys#standard-output output-port)
(##sys#standard-error output-port)

(##sys#provide (procedure ##sys#provide (symbol) boolean)
  ((symbol) (##core#inline_allocate ("C_a_i_provide" 8) #(1))))

(##sys#provided? (procedure ##sys#provided? (symbol) boolean)
  ((symbol) (##core#inline "C_i_providedp" #(1))))


;; data-structures

(chicken.data-structures#->string (procedure chicken.data-structures#->string (*) string)
	  ((string) #(1)))

(chicken.data-structures#alist-ref
 (forall (a b c d)
         (#(procedure #:clean #:foldable) chicken.data-structures#alist-ref
          (a (list-of (pair b c)) #!optional (procedure (a b) *) d)
          (or false c d))))
(chicken.data-structures#alist-update!
 (forall (a b c d)
         (#(procedure) chicken.data-structures#alist-update!
          (a b (list-of (pair c d)) #!optional (procedure (a c) *))
          (list-of (pair c (or b d))))))
(chicken.data-structures#alist-update
 (forall (a b c d)
         (#(procedure #:clean) chicken.data-structures#alist-update
          (a b (list-of (pair c d)) #!optional (procedure (a c) *))
          (list-of (pair c (or b d))))))

(chicken.data-structures#any? (#(procedure #:pure #:foldable) chicken.data-structures#any? (*) boolean)
      ((*) (let ((#(tmp) #(1))) '#t)))

(chicken.data-structures#atom? (#(procedure #:pure #:foldable) chicken.data-structures#atom? (*) boolean)
       ((pair) (let ((#(tmp) #(1))) '#f))
       (((not (or pair list))) (let ((#(tmp) #(1))) '#t)))

(chicken.data-structures#butlast (forall (a) (#(procedure #:clean #:enforce) chicken.data-structures#butlast ((pair a *)) (list-of a))))
(chicken.data-structures#chop (forall (a) (#(procedure #:clean #:enforce) chicken.data-structures#chop ((list-of a) fixnum) (list-of a))))
(chicken.data-structures#complement (#(procedure #:clean #:enforce) chicken.data-structures#complement ((procedure (#!rest) *)) (procedure (#!rest) boolean)))
(chicken.data-structures#compose (#(procedure #:clean #:enforce) chicken.data-structures#compose (#!rest procedure) procedure))
(chicken.data-structures#compress (forall (a) (#(procedure #:clean #:enforce) chicken.data-structures#compress (list (list-of a)) (list-of a))))
(chicken.data-structures#conc (procedure chicken.data-structures#conc (#!rest) string))
(chicken.data-structures#conjoin (#(procedure #:clean #:enforce) chicken.data-structures#conjoin (#!rest (procedure (*) *)) (procedure (*) *)))
(chicken.data-structures#constantly (forall (a) (#(procedure #:pure) chicken.data-structures#constantly (a) (procedure (#!rest) a))))
(chicken.data-structures#disjoin (#(procedure #:clean #:enforce) chicken.data-structures#disjoin (#!rest (procedure (*) *)) (procedure (*) *)))
(chicken.data-structures#each (#(procedure #:clean #:enforce) chicken.data-structures#each (#!rest procedure) procedure))
(chicken.data-structures#flatten (#(procedure #:clean #:enforce) chicken.data-structures#flatten (#!rest *) list))
(chicken.data-structures#flip (#(procedure #:clean #:enforce) chicken.data-structures#flip ((procedure (* *) . *)) (procedure (* *) . *)))
(chicken.data-structures#identity (forall (a) (#(procedure #:pure #:foldable) chicken.data-structures#identity (a) a)))
(chicken.data-structures#intersperse (#(procedure #:clean #:enforce) chicken.data-structures#intersperse (list *) list))
(chicken.data-structures#join (#(procedure #:clean #:enforce) chicken.data-structures#join ((list-of list) #!optional list) list))
(chicken.data-structures#list-of? (#(procedure #:clean #:enforce) chicken.data-structures#list-of? ((procedure (*) *)) (procedure (list) boolean)))

(chicken.data-structures#merge
 (forall (e)
	 (#(procedure #:enforce) chicken.data-structures#merge ((list-of e) (list-of e) (procedure (e e) *)) (list-of e))))

(chicken.data-structures#merge!
 (forall (e)
	 (#(procedure #:enforce) chicken.data-structures#merge! ((list-of e) (list-of e) (procedure (e e) *)) (list-of e))))

(chicken.data-structures#o (#(procedure #:clean #:enforce) chicken.data-structures#o (#!rest (procedure (*) *)) (procedure (*) *)))

(chicken.data-structures#rassoc
 (forall (a b c) (#(procedure #:clean #:foldable) chicken.data-structures#rassoc
                  (a (list-of (pair b c)) #!optional (procedure (a b) *))
                  (or false (pair b c)))))
(chicken.data-structures#reverse-string-append (#(procedure #:clean #:enforce) chicken.data-structures#reverse-string-append ((list-of string)) string))

(chicken.data-structures#sort
 (forall (e (s (or (vector-of e) (list-of e))))
	 (#(procedure #:enforce)
	  chicken.data-structures#sort
	  (s (procedure (e e) *))
	  s)))

(chicken.data-structures#sort!
 (forall (e (s (or (vector-of e) (list-of e))))
	 (#(procedure #:enforce)
	  chicken.data-structures#sort!
	  (s (procedure (e e) *))
	  s)))

(chicken.data-structures#sorted? (#(procedure #:enforce) chicken.data-structures#sorted? ((or list vector) (procedure (* *) *)) boolean))
(chicken.data-structures#topological-sort (#(procedure #:enforce) chicken.data-structures#topological-sort ((list-of list) (procedure (* *) *)) list))
(chicken.data-structures#string-chomp (#(procedure #:clean #:enforce) chicken.data-structures#string-chomp (string #!optional string) string))
(chicken.data-structures#string-chop (#(procedure #:clean #:enforce) chicken.data-structures#string-chop (string fixnum) (list-of string)))
(chicken.data-structures#string-compare3 (#(procedure #:clean #:enforce) chicken.data-structures#string-compare3 (string string) fixnum))
(chicken.data-structures#string-compare3-ci (#(procedure #:clean #:enforce) chicken.data-structures#string-compare3-ci (string string) fixnum))
(chicken.data-structures#string-intersperse (#(procedure #:clean #:enforce) chicken.data-structures#string-intersperse ((list-of string) #!optional string) string))
(chicken.data-structures#string-split (#(procedure #:clean #:enforce) chicken.data-structures#string-split (string #!optional string *) (list-of string)))
(chicken.data-structures#string-translate (#(procedure #:clean #:enforce) chicken.data-structures#string-translate (string * #!optional *) string))
(chicken.data-structures#string-translate* (#(procedure #:clean #:enforce) chicken.data-structures#string-translate* (string (list-of (pair string string))) string))
(chicken.data-structures#substring-ci=? (#(procedure #:clean #:enforce #:foldable) chicken.data-structures#substring-ci=? (string string #!optional fixnum fixnum fixnum) boolean))

(chicken.data-structures#substring-index (#(procedure #:clean #:enforce #:foldable) chicken.data-structures#substring-index (string string #!optional fixnum) (or false fixnum))
		 ((* *) (##sys#substring-index #(1) #(2) '0))
		 ((* * *) (##sys#substring-index #(1) #(2) #(3))))

(##sys#substring-index
 (#(procedure #:clean #:enforce #:foldable) ##sys#substring-index
  (string string fixnum)
  (or false fixnum)))

(chicken.data-structures#substring-index-ci (#(procedure #:clean #:enforce #:foldable) chicken.data-structures#substring-index-ci (string string #!optional fixnum) (or false fixnum))
		    ((* *) (##sys#substring-index-ci #(1) #(2) '0))
		    ((* * *) (##sys#substring-index-ci #(1) #(2) #(3))))

(##sys#substring-index-ci
 (#(procedure #:clean #:enforce #:foldable) ##sys#substring-index-ci
  (string string fixnum)
  (or false fixnum)))

(chicken.data-structures#substring=? (#(procedure #:clean #:enforce #:foldable) chicken.data-structures#substring=? (string string #!optional fixnum fixnum fixnum) boolean))
(chicken.data-structures#tail? (#(procedure #:clean) chicken.data-structures#tail? (* *) boolean))

;; io

(chicken.io#read-all (#(procedure #:enforce) chicken.io#read-all (#!optional input-port (procedure (input-port) *) fixnum) list))
(chicken.io#read-buffered (#(procedure #:enforce) chicken.io#read-buffered (#!optional input-port) string))
(chicken.io#read-byte (#(procedure #:enforce) chicken.io#read-byte (#!optional input-port) *))
(chicken.io#read-line (#(procedure #:enforce) chicken.io#read-line (#!optional input-port (or false fixnum)) (or eof string)))
(chicken.io#read-lines (#(procedure #:enforce) chicken.io#read-lines (#!optional input-port fixnum) (list-of string)))
(chicken.io#read-string (#(procedure #:enforce) chicken.io#read-string (#!optional (or fixnum false) input-port) (or string eof)))
(chicken.io#read-string! (#(procedure #:enforce) chicken.io#read-string! ((or fixnum false) string #!optional input-port fixnum) fixnum))
(chicken.io#read-token (#(procedure #:enforce) chicken.io#read-token ((procedure (char) *) #!optional input-port) string))
(chicken.io#write-byte (#(procedure #:enforce) chicken.io#write-byte (fixnum #!optional output-port) undefined))
(chicken.io#write-line (#(procedure #:enforce) chicken.io#write-line (string #!optional output-port) undefined))
(chicken.io#write-string (#(procedure #:enforce) chicken.io#write-string (string #!optional * output-port) undefined))

;; pretty-print

(chicken.pretty-print#pp (#(procedure #:enforce) chicken.pretty-print#pp (* #!optional output-port) undefined))
(chicken.pretty-print#pretty-print (#(procedure #:enforce) chicken.pretty-print#pretty-print (* #!optional output-port) undefined))
(chicken.pretty-print#pretty-print-width (#(procedure #:clean) chicken.pretty-print#pretty-print-width (#!optional fixnum) *))

;; format

(chicken.format#format (procedure chicken.format#format (#!rest) *))
(chicken.format#fprintf (#(procedure #:enforce) chicken.format#fprintf (output-port string #!rest) undefined))
(chicken.format#printf (#(procedure #:enforce) chicken.format#printf (string #!rest) undefined))
(chicken.format#sprintf (#(procedure #:enforce #:foldable) chicken.format#sprintf (string #!rest) string))

;; random

(chicken.random#random (#(procedure #:clean #:enforce) chicken.random#random (fixnum) fixnum))
(chicken.random#randomize (#(procedure #:clean #:enforce) chicken.random#randomize (#!optional fixnum) undefined))

;; files

(chicken.files#create-temporary-directory (#(procedure #:clean #:enforce) chicken.files#create-temporary-directory () string))
(chicken.files#create-temporary-file (#(procedure #:clean #:enforce) chicken.files#create-temporary-file (#!optional string) string))
(chicken.files#delete-file* (#(procedure #:clean #:enforce) chicken.files#delete-file* (string) *))
(chicken.files#file-copy (#(procedure #:clean #:enforce) chicken.files#file-copy (string string #!optional * fixnum) fixnum))
(chicken.files#file-move (#(procedure #:clean #:enforce) chicken.files#file-move (string string #!optional * fixnum) fixnum))

;; pathname

(chicken.pathname#absolute-pathname? (#(procedure #:clean #:enforce) chicken.pathname#absolute-pathname? (string) boolean))
(chicken.pathname#decompose-directory (#(procedure #:clean #:enforce) chicken.pathname#decompose-directory (string) * * *))
(chicken.pathname#decompose-pathname (#(procedure #:clean #:enforce) chicken.pathname#decompose-pathname (string) * * *))
(chicken.pathname#directory-null? (#(procedure #:clean #:enforce) chicken.pathname#directory-null? (string) boolean))
(chicken.pathname#make-absolute-pathname (#(procedure #:clean #:enforce) chicken.pathname#make-absolute-pathname (* #!optional string string) string))
(chicken.pathname#make-pathname (#(procedure #:clean #:enforce) chicken.pathname#make-pathname ((or string (list-of string) false) #!optional (or string false) (or string false)) string))
(chicken.pathname#normalize-pathname (#(procedure #:clean #:enforce) chicken.pathname#normalize-pathname (string #!optional symbol) string))
(chicken.pathname#pathname-directory (#(procedure #:clean #:enforce) chicken.pathname#pathname-directory (string) *))
(chicken.pathname#pathname-extension (#(procedure #:clean #:enforce) chicken.pathname#pathname-extension (string) *))
(chicken.pathname#pathname-file (#(procedure #:clean #:enforce) chicken.pathname#pathname-file (string) *))
(chicken.pathname#pathname-replace-directory (#(procedure #:clean #:enforce) chicken.pathname#pathname-replace-directory (string string) string))
(chicken.pathname#pathname-replace-extension (#(procedure #:clean #:enforce) chicken.pathname#pathname-replace-extension (string string) string))
(chicken.pathname#pathname-replace-file (#(procedure #:clean #:enforce) chicken.pathname#pathname-replace-file (string string) string))
(chicken.pathname#pathname-strip-directory (#(procedure #:clean #:enforce) chicken.pathname#pathname-strip-directory (string) string))
(chicken.pathname#pathname-strip-extension (#(procedure #:clean #:enforce) chicken.pathname#pathname-strip-extension (string) string))

;; irregex

(chicken.irregex#irregex (#(procedure #:clean) chicken.irregex#irregex (#!rest) (struct regexp)))

;; Both of these DFA accessors return either #f or a DFA vector.
;; TODO: Should we spec out the entire DFA type layout?  It's plenty complex, so we don't
;; want to be specifying this for all procedures accepting a DFA!
;; A DFA looks like a vector of lists;
;; the car of each list is a number (for init-state), false or an alist;
;; the cdr is a list of alists, which contains a char (or vector) and two alists
;; These alists have types themselves, of course...
(chicken.irregex#irregex-dfa (#(procedure #:clean #:enforce) chicken.irregex#irregex-dfa ((struct regexp)) (or false vector))
	     (((struct regexp)) (##sys#slot #(1) '1)))

(chicken.irregex#irregex-dfa/search (#(procedure #:clean #:enforce) chicken.irregex#irregex-dfa/search ((struct regexp)) (or false vector))
		    (((struct regexp)) (##sys#slot #(1) '2)))

;; Procedure type returned by irregex-nfa is a matcher type (it is misnamed)
;; which is another complex procedure type.
(chicken.irregex#irregex-nfa (#(procedure #:clean #:enforce) chicken.irregex#irregex-nfa ((struct regexp)) (or false procedure))
	     (((struct regexp)) (##sys#slot #(1) '3)))

(chicken.irregex#irregex-flags (#(procedure #:clean #:enforce) chicken.irregex#irregex-flags ((struct regexp)) fixnum)
	       (((struct regexp)) (##sys#slot #(1) '4)))

(chicken.irregex#irregex-num-submatches (#(procedure #:clean #:enforce) chicken.irregex#irregex-num-submatches ((struct regexp))
				   fixnum)
			(((struct regexp)) (##sys#slot #(1) '5)))

(chicken.irregex#irregex-lengths (#(procedure #:clean #:enforce) chicken.irregex#irregex-lengths ((struct regexp))
                  (vector-of (or false pair)))
		 (((struct regexp)) (##sys#slot #(1) '6)))

;; XXX: Submatch names ought to be symbols according to the docs, but this is
;;      not enforced anywhere, so we can't assume it in the return type here.
(chicken.irregex#irregex-names (#(procedure #:clean #:enforce) chicken.irregex#irregex-names ((struct regexp))
                (list-of (pair * fixnum)))
	       (((struct regexp)) (##sys#slot #(1) '7)))

;; XXX: specialize these? (how?)
(chicken.irregex#irregex-extract (#(procedure #:clean #:enforce) chicken.irregex#irregex-extract (* string #!optional fixnum fixnum)
                  (list-of string)))
(chicken.irregex#irregex-split (#(procedure #:clean #:enforce) chicken.irregex#irregex-split (* string #!optional fixnum fixnum)
                (list-of string)))

(chicken.irregex#irregex-fold (forall (a) (#(procedure #:enforce) chicken.irregex#irregex-fold (* (procedure (fixnum (struct regexp-match) a) a) a string #!optional (procedure (fixnum *) *) fixnum fixnum) a)))
;; XXX TODO: chunker is a plain vector
(chicken.irregex#irregex-fold/chunked (forall (a c) (#(procedure #:enforce) chicken.irregex#irregex-fold/chunked (* (procedure (c fixnum (struct regexp-match) a) a) a vector c #!optional (procedure (c fixnum a) a) fixnum fixnum) a)))
(chicken.irregex#irregex-reset-matches! (procedure chicken.irregex#irregex-reset-matches! ((struct regexp-match))
                                   (struct regexp-match)))

;; A silly procedure, but at least we can "inline" it like this
(chicken.irregex#irregex-match? (#(procedure #:clean #:enforce) chicken.irregex#irregex-match? (* string #!optional fixnum fixnum) boolean)
                ((* string) (and (irregex-match #(1) #(2)) '#t))
                ((* string fixnum) (and (irregex-match #(1) #(2) #(3)) '#t))
                ((* string fixnum fixnum) (and (irregex-match #(1) #(2) #(3) #(4)) '#t)))
;; These two return #f or a match object
(chicken.irregex#irregex-match (#(procedure #:clean #:enforce) chicken.irregex#irregex-match (* string #!optional fixnum fixnum)
                (or false (struct regexp-match))))
;; XXX chunker is a plain vector
;; Not marked clean because we don't know what chunker procedures will do
(chicken.irregex#irregex-match/chunked (#(procedure #:enforce) chicken.irregex#irregex-match/chunked (* vector * #!optional fixnum)
                        (or false (struct regexp-match))))

(chicken.irregex#irregex-match-data? (#(procedure #:pure #:predicate (struct regexp-match)) chicken.irregex#irregex-match-data? (*) boolean))

(chicken.irregex#irregex-match-end-index (#(procedure #:clean #:enforce) chicken.irregex#irregex-match-end-index ((struct regexp-match) #!optional *) fixnum))
(chicken.irregex#irregex-match-end-chunk (#(procedure #:clean #:enforce) chicken.irregex#irregex-match-end-chunk ((struct regexp-match) #!optional *) *))
(chicken.irregex#irregex-match-start-index (#(procedure #:clean #:enforce) chicken.irregex#irregex-match-start-index ((struct regexp-match) #!optional *) fixnum))
(chicken.irregex#irregex-match-start-chunk (#(procedure #:clean #:enforce) chicken.irregex#irregex-match-start-chunk ((struct regexp-match) #!optional *) *))
(chicken.irregex#irregex-match-substring (#(procedure #:clean #:enforce) chicken.irregex#irregex-match-substring ((struct regexp-match) #!optional *) *))
(chicken.irregex#irregex-match-subchunk (#(procedure #:clean #:enforce) chicken.irregex#irregex-match-subchunk ((struct regexp-match) #!optional *) *))

(chicken.irregex#irregex-match-names (#(procedure #:clean #:enforce) chicken.irregex#irregex-match-names ((struct regexp-match)) list)
		     (((struct regexp-match)) (##sys#slot #(1) '2)))

(chicken.irregex#irregex-match-num-submatches (#(procedure #:enforce) chicken.irregex#irregex-match-num-submatches ((struct regexp-match)) fixnum)
                              (((struct regexp-match))
                               (chicken.fixnum#fx- (chicken.fixnum#fx/ (##sys#size (##sys#slot #(1) '1)) '4) '2)))

(chicken.irregex#irregex-new-matches (procedure chicken.irregex#irregex-new-matches (*) *)) ; really only for internal use..
(chicken.irregex#irregex-opt (#(procedure #:clean #:enforce) chicken.irregex#irregex-opt (list) *))
(chicken.irregex#irregex-quote (#(procedure #:clean #:enforce) chicken.irregex#irregex-quote (string) string))

(chicken.irregex#irregex-replace (#(procedure #:enforce) chicken.irregex#irregex-replace (* string #!rest) string))
(chicken.irregex#irregex-replace/all (#(procedure #:enforce) chicken.irregex#irregex-replace/all (* string #!rest) string))
;; Returns a list of strings, but *only* when all user-procedures do
(chicken.irregex#irregex-apply-match (procedure ((struct regexp-match) list) list)) ; internal use

;; These return #f or a match object
(chicken.irregex#irregex-search (#(procedure #:clean #:enforce) chicken.irregex#irregex-search (* string #!optional fixnum fixnum)
                 (or false (struct regexp-match))))
;; XXX chunker is a plain vector
(chicken.irregex#irregex-search/chunked (#(procedure #:enforce) chicken.irregex#irregex-search/chunked (* vector * #!optional fixnum *)
                         (or false (struct regexp-match))))
(chicken.irregex#irregex-search/matches (#(procedure #:enforce) chicken.irregex#irregex-search/matches (* vector * * fixnum (struct regexp-match))
                         (or false (struct regexp-match))))
(chicken.irregex#irregex-match-valid-index?
 (#(procedure #:clean #:enforce) chicken.irregex#irregex-match-valid-index? ((struct regexp-match) *) boolean))

(chicken.irregex#irregex? (#(procedure #:pure #:predicate (struct regexp)) chicken.irregex#irregex? (*) boolean))

(chicken.irregex#make-irregex-chunker
 (#(procedure #:enforce) chicken.irregex#make-irregex-chunker
	    ((procedure (*) *)
	     (procedure (*) *)
	     #!optional
	     (procedure (*) *)
	     (procedure (*) *)
	     (procedure (* fixnum * fixnum) string)
	     (procedure (* fixnum * fixnum) *))
	    *))
(chicken.irregex#maybe-string->sre (#(procedure #:clean) chicken.irregex#maybe-string->sre (*) *))
(chicken.irregex#sre->irregex (#(procedure #:clean) chicken.irregex#sre->irregex (#!rest) *))
(chicken.irregex#string->irregex (#(procedure #:clean #:enforce) chicken.irregex#string->irregex (string #!rest) *))
(chicken.irregex#string->sre (#(procedure #:clean #:enforce) chicken.irregex#string->sre (string #!rest) *))


;; memory

(chicken.memory#allocate (#(procedure #:clean #:enforce) chicken.memory#allocate (fixnum) (or false pointer)))
(chicken.memory#free (#(procedure #:clean #:enforce) chicken.memory#free (pointer) undefined))

(chicken.memory#address->pointer (#(procedure #:clean #:enforce) chicken.memory#address->pointer (fixnum) pointer)
	((fixnum) (##sys#address->pointer #(1))))

(chicken.memory#pointer->address (#(procedure #:clean #:enforce) chicken.memory#pointer->address ((or pointer procedure port locative)) integer)
	((pointer) (##sys#pointer->address #(1))))

(chicken.memory#align-to-word (#(procedure #:clean) chicken.memory#align-to-word ((or number pointer locative procedure port)) (or pointer number)))

(chicken.memory#move-memory! (#(procedure #:enforce) chicken.memory#move-memory! (* * #!optional fixnum fixnum fixnum) *))

(chicken.memory#object->pointer (#(procedure #:clean) chicken.memory#object->pointer (*) *))
(chicken.memory#pointer->object (#(procedure #:clean #:enforce) chicken.memory#pointer->object (pointer) *)
	((pointer) (##core#inline "C_pointer_to_object" #(1))))

(chicken.memory#pointer+ (#(procedure #:clean #:enforce) chicken.memory#pointer+ ((or pointer procedure port locative) fixnum) pointer))
(chicken.memory#pointer? (#(procedure #:clean #:predicate pointer) chicken.memory#pointer? (*) boolean))
(chicken.memory#pointer=? (#(procedure #:clean #:enforce) chicken.memory#pointer=? ((or pointer locative procedure port)
				  (or pointer locative procedure port)) boolean)
	((pointer pointer) (##core#inline "C_pointer_eqp" #(1) #(2))))
(chicken.memory#pointer-like? (#(procedure #:pure #:predicate (or pointer locative procedure port)) chicken.memory#pointer-like? (*) boolean)
	(((or pointer locative procedure port)) (let ((#(tmp) #(1))) '#t)))

(chicken.memory#make-pointer-vector (#(procedure #:clean #:enforce) chicken.memory#make-pointer-vector (fixnum #!optional (or pointer false)) pointer-vector))
(chicken.memory#make-record-instance (#(procedure #:clean) chicken.memory#make-record-instance (symbol #!rest) *))
(chicken.memory#pointer-vector (#(procedure #:clean #:enforce) chicken.memory#pointer-vector (#!rest pointer-vector) boolean))
(chicken.memory#pointer-vector? (#(procedure #:pure #:predicate pointer-vector) chicken.memory#pointer-vector? (*) boolean))
(chicken.memory#pointer-vector-ref (#(procedure #:clean #:enforce) chicken.memory#pointer-vector-ref (pointer-vector fixnum) (or pointer false)))
(chicken.memory#pointer-vector-set! (#(procedure #:clean #:enforce) chicken.memory#pointer-vector-set! (pointer-vector fixnum (or pointer false)) undefined))
(chicken.memory#pointer-vector-fill! (#(procedure #:clean #:enforce) chicken.memory#pointer-vector-fill! (pointer-vector (or pointer false)) undefined))
(chicken.memory#pointer-vector-length (#(procedure #:clean #:enforce) chicken.memory#pointer-vector-length (pointer-vector) fixnum)
	((pointer-vector) (##sys#slot #(1) '1)))

(chicken.memory#pointer-f32-ref (#(procedure #:clean #:enforce) chicken.memory#pointer-f32-ref (pointer) number))
(chicken.memory#pointer-f32-set! (#(procedure #:clean #:enforce) chicken.memory#pointer-f32-set! (pointer number) undefined))
(chicken.memory#pointer-f64-ref (#(procedure #:clean #:enforce) chicken.memory#pointer-f64-ref (pointer) number))
(chicken.memory#pointer-f64-set! (#(procedure #:clean #:enforce) chicken.memory#pointer-f64-set! (pointer number) undefined))

(chicken.memory#pointer-s16-ref (#(procedure #:clean #:enforce) chicken.memory#pointer-s16-ref (pointer) fixnum))
(chicken.memory#pointer-s16-set! (#(procedure #:clean #:enforce) chicken.memory#pointer-s16-set! (pointer fixnum) undefined))
(chicken.memory#pointer-s32-ref (#(procedure #:clean #:enforce) chicken.memory#pointer-s32-ref (pointer) integer))
(chicken.memory#pointer-s32-set! (#(procedure #:clean #:enforce) chicken.memory#pointer-s32-set! (pointer integer) undefined))
(chicken.memory#pointer-s64-ref (#(procedure #:clean #:enforce) chicken.memory#pointer-s64-ref (pointer) integer))
(chicken.memory#pointer-s64-set! (#(procedure #:clean #:enforce) chicken.memory#pointer-s64-set! (pointer integer) undefined))
(chicken.memory#pointer-s8-ref (#(procedure #:clean #:enforce) chicken.memory#pointer-s8-ref (pointer) fixnum))
(chicken.memory#pointer-s8-set! (#(procedure #:clean #:enforce) chicken.memory#pointer-s8-set! (pointer fixnum) undefined))

(chicken.memory#pointer-u16-ref (#(procedure #:clean #:enforce) chicken.memory#pointer-u16-ref (pointer) fixnum))
(chicken.memory#pointer-u16-set! (#(procedure #:clean #:enforce) chicken.memory#pointer-u16-set! (pointer fixnum) undefined))
(chicken.memory#pointer-u32-ref (#(procedure #:clean #:enforce) chicken.memory#pointer-u32-ref (pointer) integer))
(chicken.memory#pointer-u32-set! (#(procedure #:clean #:enforce) chicken.memory#pointer-u32-set! (pointer integer) undefined))
(chicken.memory#pointer-u64-ref (#(procedure #:clean #:enforce) chicken.memory#pointer-u64-ref (pointer) integer))
(chicken.memory#pointer-u64-set! (#(procedure #:clean #:enforce) chicken.memory#pointer-u64-set! (pointer integer) undefined))
(chicken.memory#pointer-u8-ref (#(procedure #:clean #:enforce) chicken.memory#pointer-u8-ref (pointer) fixnum))
(chicken.memory#pointer-u8-set! (#(procedure #:clean #:enforce) chicken.memory#pointer-u8-set! (pointer fixnum) undefined))

(chicken.memory#tag-pointer (#(procedure #:clean #:enforce) chicken.memory#tag-pointer (pointer *) pointer))
(chicken.memory#tagged-pointer? (#(procedure #:clean #:enforce) chicken.memory#tagged-pointer? (* #!optional *) boolean))
(chicken.memory#pointer-tag (#(procedure #:clean #:enforce) chicken.memory#pointer-tag ((or pointer locative procedure port)) *)
	(((or locative procedure port)) (let ((#(tmp) #(1))) '#f)))


;; lolevel

(chicken.lolevel#block-ref (#(procedure #:clean #:enforce) chicken.lolevel#block-ref (* fixnum) *))
(chicken.lolevel#block-set! (#(procedure #:enforce) chicken.lolevel#block-set! (* fixnum *) *))
(chicken.lolevel#extend-procedure (#(procedure #:clean #:enforce) chicken.lolevel#extend-procedure (procedure *) procedure))
(chicken.lolevel#extended-procedure? (#(procedure #:clean) chicken.lolevel#extended-procedure (*) boolean))

(chicken.lolevel#mutate-procedure!
 (#(procedure #:enforce) chicken.lolevel#mutate-procedure! (procedure (procedure (procedure) . *)) procedure))

(chicken.lolevel#number-of-bytes (#(procedure #:clean) chicken.lolevel#number-of-bytes (*) fixnum)
		 (((or blob string)) (##sys#size #(1)))
		 (((or port procedure symbol pair vector locative float pointer-vector))
		  ;; would be applicable to all structure types, but we can't specify
		  ;; "(struct *)" (yet)
		  (##core#inline "C_bytes" (##sys#size #(1)))))

(chicken.lolevel#number-of-slots (#(procedure #:clean #:foldable) chicken.lolevel#number-of-slots (*) fixnum)
		 (((or vector symbol pair)) (##sys#size #(1))))

(chicken.lolevel#object-become! (procedure chicken.lolevel#object-become! (list) *))
(chicken.lolevel#object-copy (#(procedure #:clean) chicken.lolevel#object-copy (*) *))
(chicken.lolevel#procedure-data (#(procedure #:clean #:enforce) chicken.lolevel#procedure-data (procedure) *))
(chicken.lolevel#record->vector (#(procedure #:clean) chicken.lolevel#record->vector (*) vector))

(chicken.lolevel#record-instance? (#(procedure #:clean) chicken.lolevel#record-instance? (* #!optional symbol) boolean)
		  ((* symbol) (##sys#structure? #(1) #(2)))
		  ((*) (let ((#(tmp) #(1)))
			 (if (##sys#immediate? #(tmp))
			     '#f
			     (##sys#generic-structure? #(tmp))))))

(chicken.lolevel#record-instance-length (#(procedure #:clean) chicken.lolevel#record-instance-length (*) fixnum))
(chicken.lolevel#record-instance-slot (#(procedure #:clean #:enforce) chicken.lolevel#record-instance-slot (* fixnum) *))
(chicken.lolevel#record-instance-slot-set! (#(procedure #:clean #:enforce) chicken.lolevel#record-instance-slot-set! (* fixnum *) undefined))
(chicken.lolevel#record-instance-type (#(procedure #:clean) chicken.lolevel#record-instance-type (*) *))
(chicken.lolevel#set-procedure-data! (#(procedure #:clean #:enforce) chicken.lolevel#set-procedure-data! (procedure *) undefined))

;; locative

(chicken.locative#locative->object (#(procedure #:clean #:enforce) chicken.locative#locative->object (locative) *))
(chicken.locative#locative-ref (#(procedure #:clean #:enforce) chicken.locative#locative-ref (locative) *)
		((locative) (##core#inline_allocate ("C_a_i_locative_ref" 6) #(1))))
(chicken.locative#locative-set! (#(procedure #:enforce) chicken.locative#locative-set! (locative *) *))
(chicken.locative#locative? (#(procedure #:pure #:predicate locative) chicken.locative#locative? (*) boolean))
(chicken.locative#make-locative (#(procedure #:clean #:enforce) chicken.locative#make-locative (* #!optional fixnum) locative))
(chicken.locative#make-weak-locative (#(procedure #:clean #:enforce) chicken.locative#make-weak-locative (* #!optional fixnum) locative))

;; ports

(chicken.ports#call-with-input-string (#(procedure #:enforce) chicken.ports#call-with-input-string (string (procedure (input-port) . *)) . *))
(chicken.ports#call-with-output-string (#(procedure #:enforce) chicken.ports#call-with-output-string ((procedure (output-port) . *)) string))
(chicken.ports#copy-port (#(procedure #:enforce) chicken.ports#copy-port (* * #!optional (procedure (*) *) (procedure (* output-port) *)) undefined))
(chicken.ports#make-input-port (#(procedure #:clean #:enforce) chicken.ports#make-input-port ((procedure () (or char eof)) (procedure () *) (procedure () . *) #!optional * * * *) input-port))
(chicken.ports#make-output-port (#(procedure #:clean #:enforce) chicken.ports#make-output-port ((procedure (string) . *) (procedure () . *) #!optional (procedure () . *)) output-port))
(chicken.ports#port-for-each (#(procedure #:enforce) chicken.ports#port-for-each ((procedure (*) *) (procedure () . *)) undefined))

(chicken.ports#port-map
 (forall (a b) (#(procedure #:enforce) chicken.ports#port-map ((procedure (a) b) (procedure () a)) (list-of b))))

(chicken.ports#port-fold (#(procedure #:enforce) chicken.ports#port-fold ((procedure (* *) *) * (procedure () *)) *))
(chicken.ports#make-bidirectional-port (#(procedure #:clean #:enforce) chicken.ports#make-bidirectional-port (input-port output-port) (refine (input output) port)))
(chicken.ports#make-broadcast-port (#(procedure #:clean #:enforce) chicken.ports#make-broadcast-port (#!rest output-port) output-port))
(chicken.ports#make-concatenated-port (#(procedure #:clean #:enforce) chicken.ports#make-concatenated-port (port #!rest input-port) input-port))
(chicken.ports#with-error-to-port (#(procedure #:enforce) chicken.ports#with-error-to-port (output-port (procedure () . *)) . *))
(chicken.ports#with-input-from-port (#(procedure #:enforce) chicken.ports#with-input-from-port (input-port (procedure () . *)) . *))
(chicken.ports#with-input-from-string (#(procedure #:enforce) chicken.ports#with-input-from-string (string (procedure () . *)) . *))
(chicken.ports#with-output-to-port (#(procedure #:enforce) chicken.ports#with-output-to-port (output-port (procedure () . *)) . *))
(chicken.ports#with-output-to-string (#(procedure #:enforce) chicken.ports#with-output-to-string ((procedure () . *)) string))
(chicken.ports#with-error-to-string (#(procedure #:enforce) chicken.ports#with-error-to-string ((procedure () . *)) string))

;; errno

(chicken.errno#errno/2big fixnum)
(chicken.errno#errno/acces fixnum)
(chicken.errno#errno/again fixnum)
(chicken.errno#errno/badf fixnum)
(chicken.errno#errno/busy fixnum)
(chicken.errno#errno/child fixnum)
(chicken.errno#errno/deadlk fixnum)
(chicken.errno#errno/dom fixnum)
(chicken.errno#errno/exist fixnum)
(chicken.errno#errno/fault fixnum)
(chicken.errno#errno/fbig fixnum)
(chicken.errno#errno/ilseq fixnum)
(chicken.errno#errno/intr fixnum)
(chicken.errno#errno/inval fixnum)
(chicken.errno#errno/io fixnum)
(chicken.errno#errno/isdir fixnum)
(chicken.errno#errno/mfile fixnum)
(chicken.errno#errno/mlink fixnum)
(chicken.errno#errno/nametoolong fixnum)
(chicken.errno#errno/nfile fixnum)
(chicken.errno#errno/nodev fixnum)
(chicken.errno#errno/noent fixnum)
(chicken.errno#errno/noexec fixnum)
(chicken.errno#errno/nolck fixnum)
(chicken.errno#errno/nomem fixnum)
(chicken.errno#errno/nospc fixnum)
(chicken.errno#errno/nosys fixnum)
(chicken.errno#errno/notdir fixnum)
(chicken.errno#errno/notempty fixnum)
(chicken.errno#errno/notty fixnum)
(chicken.errno#errno/nxio fixnum)
(chicken.errno#errno/perm fixnum)
(chicken.errno#errno/pipe fixnum)
(chicken.errno#errno/range fixnum)
(chicken.errno#errno/rofs fixnum)
(chicken.errno#errno/spipe fixnum)
(chicken.errno#errno/srch fixnum)
(chicken.errno#errno/wouldblock fixnum)
(chicken.errno#errno/xdev fixnum)

;; posix

(chicken.posix#emergency-exit (procedure chicken.posix#emergency-exit (#!optional fixnum) noreturn))
(chicken.posix#call-with-input-pipe (#(procedure #:enforce) chicken.posix#call-with-input-pipe (string (procedure (input-port) . *) #!optional symbol) . *))
(chicken.posix#call-with-output-pipe (#(procedure #:enforce) chicken.posix#call-with-output-pipe (string (procedure (input-port) . *) #!optional symbol) . *))
(chicken.posix#change-directory (#(procedure #:clean #:enforce) chicken.posix#change-directory (string) string))
(chicken.posix#change-directory* (#(procedure #:clean #:enforce) chicken.posix#change-directory* (fixnum) fixnum))
(chicken.posix#change-file-mode (#(procedure #:clean #:enforce) chicken.posix#change-file-mode (string fixnum) undefined))
(chicken.posix#change-file-owner (#(procedure #:clean #:enforce) chicken.posix#change-file-owner (string fixnum fixnum) undefined))
(chicken.posix#close-input-pipe (#(procedure #:clean #:enforce) chicken.posix#close-input-pipe (input-port) fixnum))
(chicken.posix#close-output-pipe (#(procedure #:clean #:enforce) chicken.posix#close-output-pipe (output-port) fixnum))
(chicken.posix#create-directory (#(procedure #:clean #:enforce) chicken.posix#create-directory (string #!optional *) string))
(chicken.posix#create-fifo (#(procedure #:clean #:enforce) chicken.posix#create-fifo (string #!optional fixnum) undefined))
(chicken.posix#create-pipe (procedure chicken.posix#create-pipe () fixnum fixnum))
(chicken.posix#create-session (#(procedure #:clean) chicken.posix#create-session () fixnum))
(chicken.posix#create-symbolic-link (#(procedure #:clean #:enforce) chicken.posix#create-symbolic-link (string string) undefined))

;; extra arg for "parameterize" - ugh, what a hack...
(chicken.posix#current-directory (#(procedure #:clean #:enforce) chicken.posix#current-directory (#!optional string *) string))

(chicken.posix#current-effective-group-id (#(procedure #:clean) chicken.posix#current-effective-group-id () fixnum))
(chicken.posix#current-effective-user-id (#(procedure #:clean) chicken.posix#current-effective-user-id () fixnum))
(chicken.posix#current-effective-user-name (#(procedure #:clean) chicken.posix#current-effective-user-name () string))
(chicken.posix#get-environment-variables (#(procedure #:clean) chicken.posix#get-environment-variables () (list-of (pair string string))))
(chicken.posix#current-group-id (#(procedure #:clean) chicken.posix#current-group-id () fixnum))
(chicken.posix#current-process-id (#(procedure #:clean) chicken.posix#current-process-id () fixnum))
(chicken.posix#current-user-id (#(procedure #:clean) chicken.posix#current-user-id () fixnum))
(chicken.posix#current-user-name (#(procedure #:clean) chicken.posix#current-user-name () string))
(chicken.posix#delete-directory (#(procedure #:clean #:enforce) chicken.posix#delete-directory (string #!optional *) string))
(chicken.posix#directory (#(procedure #:clean #:enforce) chicken.posix#directory (#!optional string *) (list-of string)))
(chicken.posix#directory? (#(procedure #:clean #:enforce) chicken.posix#directory? ((or string fixnum)) boolean))
(chicken.posix#duplicate-fileno (#(procedure #:clean #:enforce) chicken.posix#duplicate-fileno (fixnum #!optional fixnum) fixnum))
(chicken.posix#fcntl/dupfd fixnum)
(chicken.posix#fcntl/getfd fixnum)
(chicken.posix#fcntl/getfl fixnum)
(chicken.posix#fcntl/setfd fixnum)
(chicken.posix#fcntl/setfl fixnum)
(chicken.posix#file-access-time (#(procedure #:clean #:enforce) chicken.posix#file-access-time ((or string fixnum)) integer))
(chicken.posix#file-change-time (#(procedure #:clean #:enforce) chicken.posix#file-change-time ((or string fixnum)) integer))
(chicken.posix#file-close (#(procedure #:clean #:enforce) chicken.posix#file-close (fixnum) undefined))
(chicken.posix#file-control (#(procedure #:clean #:enforce) chicken.posix#file-control (fixnum fixnum #!optional fixnum) fixnum))
(chicken.posix#file-creation-mode (#(procedure #:clean #:enforce) chicken.posix#file-creation-mode (#!optional fixnum) fixnum))
(chicken.posix#file-execute-access? (#(procedure #:clean #:enforce) chicken.posix#file-execute-access? (string) boolean))
(chicken.posix#file-link (#(procedure #:clean #:enforce) chicken.posix#file-link (string string) undefined))
(chicken.posix#file-lock (#(procedure #:clean #:enforce) chicken.posix#file-lock (port #!optional fixnum integer) (struct lock)))
(chicken.posix#file-lock/blocking (#(procedure #:clean #:enforce) chicken.posix#file-lock/blocking (port #!optional fixnum integer) (struct lock)))
(chicken.posix#file-mkstemp (#(procedure #:clean #:enforce) chicken.posix#file-mkstemp (string) fixnum string))
(chicken.posix#file-modification-time (#(procedure #:clean #:enforce) chicken.posix#file-modification-time ((or string fixnum)) integer))
(chicken.posix#file-open (#(procedure #:clean #:enforce) chicken.posix#file-open (string fixnum #!optional fixnum) fixnum))
(chicken.posix#file-owner (#(procedure #:clean #:enforce) chicken.posix#file-owner ((or string fixnum)) fixnum))
(chicken.posix#file-permissions (#(procedure #:clean #:enforce) chicken.posix#file-permissions ((or string fixnum)) fixnum))
(chicken.posix#file-position (#(procedure #:clean #:enforce) chicken.posix#file-position ((or port fixnum)) integer))
(chicken.posix#file-read (#(procedure #:clean #:enforce) chicken.posix#file-read (fixnum fixnum #!optional *) list))
(chicken.posix#file-read-access? (#(procedure #:clean #:enforce) chicken.posix#file-read-access? (string) boolean))
(chicken.posix#file-select (#(procedure #:clean #:enforce) chicken.posix#file-select ((or (list-of fixnum) fixnum false) (or (list-of fixnum) fixnum false) #!optional fixnum) * *))
(chicken.posix#file-size (#(procedure #:clean #:enforce) chicken.posix#file-size ((or string fixnum)) integer))
(chicken.posix#file-stat (#(procedure #:clean #:enforce) chicken.posix#file-stat ((or string fixnum) #!optional *) (vector-of integer)))
(chicken.posix#file-test-lock (#(procedure #:clean #:enforce) chicken.posix#file-test-lock (port #!optional fixnum *) boolean))
(chicken.posix#file-truncate (#(procedure #:clean #:enforce) chicken.posix#file-truncate ((or string fixnum) integer) undefined))
(chicken.posix#file-type (#(procedure #:clean #:enforce) chicken.posix#file-type ((or string fixnum) #!optional * *) symbol))
(chicken.posix#file-unlock (#(procedure #:clean #:enforce) chicken.posix#file-unlock ((struct lock)) undefined))
(chicken.posix#file-write (#(procedure #:clean #:enforce) chicken.posix#file-write (fixnum * #!optional fixnum) fixnum))
(chicken.posix#file-write-access? (#(procedure #:clean #:enforce) chicken.posix#file-write-access? (string) boolean))
(chicken.posix#fileno/stderr fixnum)
(chicken.posix#fileno/stdin fixnum)
(chicken.posix#fileno/stdout fixnum)
(chicken.posix#find-files (#(procedure #:enforce) chicken.posix#find-files (string #!rest) list))
(chicken.posix#get-host-name (#(procedure #:clean) chicken.posix#get-host-name () string))
(chicken.posix#glob (#(procedure #:clean #:enforce) chicken.posix#glob (#!rest string) list))
(chicken.posix#local-time->seconds (#(procedure #:clean #:enforce) chicken.posix#local-time->seconds ((vector fixnum fixnum fixnum fixnum fixnum fixnum fixnum fixnum boolean fixnum)) integer))
(chicken.posix#local-timezone-abbreviation (#(procedure #:clean) chicken.posix#local-timezone-abbreviation () string))
(chicken.posix#open-input-file* (#(procedure #:clean #:enforce) chicken.posix#open-input-file* (fixnum #!optional symbol) input-port))
(chicken.posix#open-input-pipe (#(procedure #:clean #:enforce) chicken.posix#open-input-pipe (string #!optional symbol) input-port))
(chicken.posix#open-output-file* (#(procedure #:clean #:enforce) chicken.posix#open-output-file* (fixnum #!optional symbol) output-port))
(chicken.posix#open-output-pipe (#(procedure #:clean #:enforce) chicken.posix#open-output-pipe (string #!optional symbol) output-port))
(chicken.posix#open/append fixnum)
(chicken.posix#open/binary fixnum)
(chicken.posix#open/creat fixnum)
(chicken.posix#open/excl fixnum)
(chicken.posix#open/fsync fixnum)
(chicken.posix#open/noctty fixnum)
(chicken.posix#open/nonblock fixnum)
(chicken.posix#open/rdonly fixnum)
(chicken.posix#open/rdwr fixnum)
(chicken.posix#open/read fixnum)
(chicken.posix#open/sync fixnum)
(chicken.posix#open/text fixnum)
(chicken.posix#open/trunc fixnum)
(chicken.posix#open/write fixnum)
(chicken.posix#open/wronly fixnum)
(chicken.posix#parent-process-id (#(procedure #:clean) chicken.posix#parent-process-id () fixnum))
(chicken.posix#perm/irgrp fixnum)
(chicken.posix#perm/iroth fixnum)
(chicken.posix#perm/irusr fixnum)
(chicken.posix#perm/irwxg fixnum)
(chicken.posix#perm/irwxo fixnum)
(chicken.posix#perm/irwxu fixnum)
(chicken.posix#perm/isgid fixnum)
(chicken.posix#perm/isuid fixnum)
(chicken.posix#perm/isvtx fixnum)
(chicken.posix#perm/iwgrp fixnum)
(chicken.posix#perm/iwoth fixnum)
(chicken.posix#perm/iwusr fixnum)
(chicken.posix#perm/ixgrp fixnum)
(chicken.posix#perm/ixoth fixnum)
(chicken.posix#perm/ixusr fixnum)
(chicken.posix#pipe/buf fixnum)
(chicken.posix#port->fileno (#(procedure #:clean #:enforce) chicken.posix#port->fileno (port) fixnum))
(chicken.posix#process (#(procedure #:clean #:enforce) chicken.posix#process (string #!optional (list-of string) (list-of (pair string string))) input-port output-port fixnum))
(chicken.posix#process* (#(procedure #:clean #:enforce) chicken.posix#process* (string #!optional (list-of string) (list-of (pair string string))) input-port output-port fixnum *))

(chicken.posix#process-execute
 (#(procedure #:clean #:enforce) chicken.posix#process-execute (string #!optional (list-of string) (list-of (pair string string))) noreturn))

(chicken.posix#process-fork (#(procedure #:enforce) chicken.posix#process-fork (#!optional (or (procedure () . *) false) *) fixnum))

(chicken.posix#process-group-id (#(procedure #:clean #:enforce) chicken.posix#process-group-id () fixnum))
(chicken.posix#process-run (#(procedure #:clean #:enforce) chicken.posix#process-run (string #!optional (list-of string)) fixnum))
(chicken.posix#process-signal (#(procedure #:clean #:enforce) chicken.posix#process-signal (fixnum #!optional fixnum) undefined))
(chicken.posix#process-wait (#(procedure #:clean #:enforce) chicken.posix#process-wait (#!optional fixnum *) fixnum fixnum fixnum))
(chicken.posix#read-symbolic-link (#(procedure #:clean #:enforce) chicken.posix#read-symbolic-link (string #!optional boolean) string))
(chicken.posix#regular-file? (#(procedure #:clean #:enforce) chicken.posix#regular-file? ((or string fixnum)) boolean))
(chicken.posix#seconds->local-time (#(procedure #:clean #:enforce) chicken.posix#seconds->local-time (#!optional integer) (vector fixnum fixnum fixnum fixnum fixnum fixnum fixnum fixnum boolean fixnum)))
(chicken.posix#seconds->string (#(procedure #:clean #:enforce) chicken.posix#seconds->string (#!optional integer) string))
(chicken.posix#seconds->utc-time (#(procedure #:clean #:enforce) chicken.posix#seconds->utc-time (#!optional integer) (vector fixnum fixnum fixnum fixnum fixnum fixnum fixnum fixnum boolean fixnum)))
(chicken.posix#seek/cur fixnum)
(chicken.posix#seek/end fixnum)
(chicken.posix#seek/set fixnum)
(chicken.posix#set-alarm! (#(procedure #:clean #:enforce) chicken.posix#set-alarm! (integer) integer))
(chicken.posix#set-buffering-mode! (#(procedure #:clean #:enforce) chicken.posix#set-buffering-mode! (port symbol #!optional fixnum) undefined))
(chicken.posix#set-file-position! (#(procedure #:clean #:enforce) chicken.posix#set-file-position! ((or port fixnum) integer #!optional fixnum) undefined))
(chicken.posix#set-root-directory! (#(procedure #:clean #:enforce) chicken.posix#set-root-directory! (string) undefined))
(chicken.posix#set-signal-handler! (#(procedure #:clean #:enforce) chicken.posix#set-signal-handler! (fixnum (or false (procedure (fixnum) . *))) undefined))
(chicken.posix#set-signal-mask! (#(procedure #:clean #:enforce) chicken.posix#set-signal-mask! ((list-of fixnum)) undefined))
(chicken.posix#set-environment-variable! (#(procedure #:clean #:enforce) chicken.posix#set-environment-variable! (string string) undefined))
(chicken.posix#signal-handler (#(procedure #:clean #:enforce) chicken.posix#signal-handler (fixnum) (or false (procedure (fixnum) . *))))
(chicken.posix#signal-mask (#(procedure #:clean) chicken.posix#signal-mask () fixnum))
(chicken.posix#signal-mask! (#(procedure #:clean #:enforce) chicken.posix#signal-mask! (fixnum) undefined))
(chicken.posix#signal-masked? (#(procedure #:clean #:enforce) chicken.posix#signal-masked? (fixnum) boolean))
(chicken.posix#signal-unmask! (#(procedure #:clean #:enforce) chicken.posix#signal-unmask! (fixnum) undefined))
(chicken.posix#signal/abrt fixnum)
(chicken.posix#signal/alrm fixnum)
(chicken.posix#signal/chld fixnum)
(chicken.posix#signal/cont fixnum)
(chicken.posix#signal/fpe fixnum)
(chicken.posix#signal/hup fixnum)
(chicken.posix#signal/ill fixnum)
(chicken.posix#signal/int fixnum)
(chicken.posix#signal/io fixnum)
(chicken.posix#signal/bus fixnum)
(chicken.posix#signal/kill fixnum)
(chicken.posix#signal/pipe fixnum)
(chicken.posix#signal/prof fixnum)
(chicken.posix#signal/quit fixnum)
(chicken.posix#signal/segv fixnum)
(chicken.posix#signal/stop fixnum)
(chicken.posix#signal/term fixnum)
(chicken.posix#signal/trap fixnum)
(chicken.posix#signal/tstp fixnum)
(chicken.posix#signal/urg fixnum)
(chicken.posix#signal/usr1 fixnum)
(chicken.posix#signal/usr2 fixnum)
(chicken.posix#signal/vtalrm fixnum)
(chicken.posix#signal/winch fixnum)
(chicken.posix#signal/xcpu fixnum)
(chicken.posix#signal/xfsz fixnum)
(chicken.posix#signals-list list)
(chicken.posix#process-sleep (#(procedure #:clean #:enforce) chicken.posix#process-sleep (fixnum) fixnum))
(chicken.posix#block-device? (#(procedure #:clean #:enforce) chicken.posix#block-device? ((or string fixnum)) boolean))
(chicken.posix#character-device? (#(procedure #:clean #:enforce) chicken.posix#character-device? ((or string fixnum)) boolean))
(chicken.posix#fifo? (#(procedure #:clean #:enforce) chicken.posix#fifo? ((or string fixnum)) boolean))
(chicken.posix#socket? (#(procedure #:clean #:enforce) chicken.posix#socket? ((or string fixnum)) boolean))
(chicken.posix#string->time (#(procedure #:clean #:enforce) chicken.posix#string->time (string #!optional string) (vector fixnum fixnum fixnum fixnum fixnum fixnum fixnum fixnum boolean fixnum)))
(chicken.posix#symbolic-link? (#(procedure #:clean #:enforce) chicken.posix#symbolic-link? ((or string fixnum)) boolean))
(chicken.posix#system-information (#(procedure #:clean) chicken.posix#system-information () list))
(chicken.posix#terminal-name (#(procedure #:clean #:enforce) chicken.posix#terminal-name (port) string))
(chicken.posix#terminal-port? (#(procedure #:clean #:enforce) chicken.posix#terminal-port? (port) boolean))
(chicken.posix#terminal-size (#(procedure #:clean #:enforce) chicken.posix#terminal-size (port) fixnum fixnum))
(chicken.posix#time->string (#(procedure #:clean #:enforce) chicken.posix#time->string ((vector fixnum fixnum fixnum fixnum fixnum fixnum fixnum fixnum boolean fixnum) #!optional string) string))
(chicken.posix#unmap-file-from-memory (#(procedure #:clean #:enforce) chicken.posix#unmap-file-from-memory ((struct mmap) #!optional fixnum) undefined))
(chicken.posix#unset-environment-variable! (#(procedure #:clean #:enforce) chicken.posix#unset-environment-variable! (string) undefined))
(chicken.posix#user-information (#(procedure #:clean #:enforce) chicken.posix#user-information ((or string fixnum) #!optional *) *))
(chicken.posix#utc-time->seconds (#(procedure #:clean #:enforce) chicken.posix#utc-time->seconds ((vector fixnum fixnum fixnum fixnum fixnum fixnum fixnum fixnum boolean fixnum)) integer))
(chicken.posix#with-input-from-pipe (#(procedure #:enforce) chicken.posix#with-input-from-pipe (string (procedure () . *) #!optional symbol) . *))
(chicken.posix#with-output-to-pipe (#(procedure #:enforce) chicken.posix#with-output-to-pipe (string (procedure () . *) #!optional symbol) . *))


;; srfi-4

(srfi-4#blob->f32vector (#(procedure #:clean #:enforce) srfi-4#blob->f32vector (blob) (struct f32vector)))
(srfi-4#blob->f32vector/shared (#(procedure #:clean #:enforce) srfi-4#blob->f32vector/shared (blob) (struct f32vector)))
(srfi-4#blob->f64vector (#(procedure #:clean #:enforce) srfi-4#blob->f64vector (blob) (struct f64vector)))
(srfi-4#blob->f64vector/shared (#(procedure #:clean #:enforce) srfi-4#blob->f64vector/shared (blob) (struct f64vector)))
(srfi-4#blob->s16vector (#(procedure #:clean #:enforce) srfi-4#blob->s16vector (blob) (struct s16vector)))
(srfi-4#blob->s16vector/shared (#(procedure #:clean #:enforce) srfi-4#blob->s16vector/shared (blob) (struct s16vector)))
(srfi-4#blob->s32vector (#(procedure #:clean #:enforce) srfi-4#blob->s32vector (blob) (struct s32vector)))
(srfi-4#blob->s32vector/shared (#(procedure #:clean #:enforce) srfi-4#blob->s32vector/shared (blob) (struct s32vector)))
(srfi-4#blob->s8vector (#(procedure #:clean #:enforce) srfi-4#blob->s8vector (blob) (struct s8vector)))
(srfi-4#blob->s8vector/shared (#(procedure #:clean #:enforce) srfi-4#blob->s8vector/shared (blob) (struct s8vector)))
(srfi-4#blob->u16vector (#(procedure #:clean #:enforce) srfi-4#blob->u16vector (blob) (struct u16vector)))
(srfi-4#blob->u16vector/shared (#(procedure #:clean #:enforce) srfi-4#blob->u16vector/shared (blob) (struct u16vector)))
(srfi-4#blob->u32vector (#(procedure #:clean #:enforce) srfi-4#blob->u32vector (blob) (struct u32vector)))
(srfi-4#blob->u32vector/shared (#(procedure #:clean #:enforce) srfi-4#blob->u32vector/shared (blob) (struct u32vector)))
(srfi-4#blob->u64vector (#(procedure #:clean #:enforce) srfi-4#blob->u64vector (blob) (struct u64vector)))
(srfi-4#blob->u64vector/shared (#(procedure #:clean #:enforce) srfi-4#blob->u64vector/shared (blob) (struct u64vector)))
(srfi-4#blob->u8vector (#(procedure #:clean #:enforce) blob->u8vector (blob) (struct u8vector)))
(srfi-4#blob->u8vector/shared (#(procedure #:clean #:enforce) srfi-4#blob->u8vector/shared (blob) (struct u8vector)))
(srfi-4#f32vector (#(procedure #:clean #:enforce) srfi-4#f32vector (#!rest (or integer float)) (struct f32vector)))
(srfi-4#f32vector->blob (#(procedure #:clean #:enforce) srfi-4#f32vector->blob ((struct f32vector)) blob))
(srfi-4#f32vector->blob/shared (#(procedure #:clean #:enforce) srfi-4#f32vector->blob/shared ((struct f32vector)) blob))
(srfi-4#f32vector->list (#(procedure #:clean #:enforce) srfi-4#f32vector->list ((struct f32vector)) (list-of float)))

(srfi-4#f32vector-length (#(procedure #:clean #:enforce) srfi-4#f32vector-length ((struct f32vector)) fixnum)
		  (((struct f32vector)) (##core#inline "C_u_i_32vector_length" #(1))))

(srfi-4#f32vector-ref (#(procedure #:clean #:enforce) srfi-4#f32vector-ref ((struct f32vector) fixnum) float))
(srfi-4#f32vector-set! (#(procedure #:clean #:enforce) srfi-4#f32vector-set! ((struct f32vector) fixnum (or integer float)) undefined))

(srfi-4#f32vector? (#(procedure #:pure #:predicate (struct f32vector)) srfi-4#f32vector? (*) boolean))

(srfi-4#f64vector (#(procedure #:clean #:enforce) srfi-4#f64vector (#!rest (or integer float)) (struct f64vector)))
(srfi-4#f64vector->blob (#(procedure #:clean #:enforce) srfi-4#f64vector->blob ((struct f64vector)) blob))
(srfi-4#f64vector->blob/shared (#(procedure #:clean #:enforce) srfi-4#f64vector->blob/shared ((struct f64vector)) blob))
(srfi-4#f64vector->list (#(procedure #:clean #:enforce) srfi-4#f64vector->list ((struct f64vector)) (list-of float)))

(srfi-4#f64vector-length (#(procedure #:clean #:enforce) srfi-4#f64vector-length ((struct f64vector)) fixnum)
		  (((struct f64vector)) (##core#inline "C_u_i_64vector_length" #(1))))

(srfi-4#f64vector-ref (#(procedure #:clean #:enforce) srfi-4#f64vector-ref ((struct f64vector) fixnum) float))
(srfi-4#f64vector-set! (#(procedure #:clean #:enforce) srfi-4#f64vector-set! ((struct f64vector) fixnum (or integer float)) undefined))

(srfi-4#f64vector? (#(procedure #:pure #:predicate (struct f64vector)) srfi-4#f64vector? (*) boolean))

(srfi-4#list->f32vector (#(procedure #:clean #:enforce) srfi-4#list->f32vector ((list-of (or float integer))) (struct f32vector)))
(srfi-4#list->f64vector (#(procedure #:clean #:enforce) srfi-4#list->f64vector ((list-of (or float integer))) (struct f64vector)))
(srfi-4#list->s16vector (#(procedure #:clean #:enforce) srfi-4#list->s16vector ((list-of fixnum)) (struct s16vector)))
(srfi-4#list->s32vector (#(procedure #:clean #:enforce) srfi-4#list->s32vector ((list-of integer)) (struct s32vector)))
(srfi-4#list->s8vector (#(procedure #:clean #:enforce) srfi-4#list->s8vector ((list-of fixnum)) (struct s8vector)))
(srfi-4#list->u16vector (#(procedure #:clean #:enforce) srfi-4#list->u16vector ((list-of fixnum)) (struct u16vector)))
(srfi-4#list->u32vector (#(procedure #:clean #:enforce) srfi-4#list->u32vector ((list-of integer)) (struct u32vector)))
(srfi-4#list->u64vector (#(procedure #:clean #:enforce) srfi-4#list->u64vector ((list-of integer)) (struct u64vector)))
(srfi-4#list->u8vector (#(procedure #:clean #:enforce) srfi-4#list->u8vector ((list-of fixnum)) (struct u8vector)))
(srfi-4#make-f32vector (#(procedure #:clean #:enforce) srfi-4#make-f32vector (fixnum #!optional (or integer float false) boolean boolean) (struct f32vector)))
(srfi-4#make-f64vector (#(procedure #:clean #:enforce) srfi-4#make-f64vector (fixnum #!optional (or integer float false) boolean) (struct f64vector)))
(srfi-4#make-s16vector (#(procedure #:clean #:enforce) srfi-4#make-s16vector (fixnum #!optional (or fixnum false) boolean boolean) (struct s16vector)))
(srfi-4#make-s32vector (#(procedure #:clean #:enforce) srfi-4#make-s32vector (fixnum #!optional (or integer false) boolean boolean) (struct s32vector)))
(srfi-4#make-s8vector (#(procedure #:clean #:enforce) srfi-4#make-s8vector (fixnum #!optional (or fixnum false) boolean boolean) (struct s8vector)))
(srfi-4#make-u16vector (#(procedure #:clean #:enforce) srfi-4#make-u16vector (fixnum #!optional (or fixnum false) boolean boolean) (struct u16vector)))
(srfi-4#make-u32vector (#(procedure #:clean #:enforce) srfi-4#make-u32vector (fixnum #!optional (or integer false) boolean boolean) (struct u32vector)))
(srfi-4#make-u64vector (#(procedure #:clean #:enforce) srfi-4#make-u64vector (fixnum #!optional (or integer false) boolean boolean) (struct u64vector)))
(srfi-4#make-u8vector (#(procedure #:clean #:enforce) srfi-4#make-u8vector (fixnum #!optional (or fixnum false) boolean boolean) (struct u8vector)))
(srfi-4#read-u8vector (#(procedure #:enforce) srfi-4#read-u8vector (#!optional (or fixnum false) input-port) (or (struct u8vector) eof)))
(srfi-4#read-u8vector! (#(procedure #:enforce) srfi-4#read-u8vector! ((or fixnum false) (struct u8vector) #!optional input-port fixnum) integer))
(srfi-4#release-number-vector (procedure srfi-4#release-number-vector (*) undefined))
(srfi-4#s16vector (#(procedure #:clean #:enforce) srfi-4#s16vector (#!rest fixnum) (struct s16vector)))
(srfi-4#s16vector->blob (#(procedure #:clean #:enforce) srfi-4#s16vector->blob ((struct s16vector)) blob))
(srfi-4#s16vector->blob/shared (#(procedure #:clean #:enforce) srfi-4#s16vector->blob/shared ((struct s16vector)) blob))
(srfi-4#s16vector->list (#(procedure #:clean #:enforce) srfi-4#s16vector->list ((struct s16vector)) (list-of fixnum)))

(srfi-4#s16vector-length (#(procedure #:clean #:enforce) srfi-4#s16vector-length ((struct s16vector)) fixnum)
		  (((struct s16vector)) (##core#inline "C_u_i_16vector_length" #(1))))

(srfi-4#s16vector-ref (#(procedure #:clean #:enforce) srfi-4#s16vector-ref ((struct s16vector) fixnum) fixnum))
(srfi-4#s16vector-set! (#(procedure #:clean #:enforce) srfi-4#s16vector-set! ((struct s16vector) fixnum fixnum) undefined))

(srfi-4#s16vector? (#(procedure #:pure #:predicate (struct s16vector)) srfi-4#s16vector? (*) boolean))

(srfi-4#s32vector (#(procedure #:clean #:enforce) srfi-4#s32vector (#!rest integer) (struct s32vector)))
(srfi-4#s32vector->blob (#(procedure #:clean #:enforce) srfi-4#s32vector->blob ((struct s32vector)) blob))
(srfi-4#s32vector->blob/shared (#(procedure #:clean #:enforce) srfi-4#s32vector->blob/shared ((struct s32vector)) blob))
(srfi-4#s32vector->list (#(procedure #:clean #:enforce) srfi-4#s32vector->list ((struct s32vector)) (list-of integer)))

(srfi-4#s32vector-length (#(procedure #:clean #:enforce) srfi-4#s32vector-length ((struct s32vector)) fixnum)
		  (((struct s32vector)) (##core#inline "C_u_i_32vector_length" #(1))))

(srfi-4#s32vector-ref (#(procedure #:clean #:enforce) srfi-4#s32vector-ref ((struct s32vector) fixnum) integer))
(srfi-4#s32vector-set! (#(procedure #:clean #:enforce) srfi-4#s32vector-set! ((struct s32vector) fixnum integer) undefined))

(srfi-4#s32vector? (#(procedure #:pure #:predicate (struct s32vector)) srfi-4#s32vector? (*) boolean))

(srfi-4#s8vector (#(procedure #:clean #:enforce) srfi-4#s8vector (#!rest fixnum) (struct s8vector)))
(srfi-4#s8vector->blob (#(procedure #:clean #:enforce) srfi-4#s8vector->blob ((struct s8vector)) blob))
(srfi-4#s8vector->blob/shared (#(procedure #:clean #:enforce) srfi-4#s8vector->blob/shared ((struct s8vector)) blob))
(srfi-4#s8vector->list (#(procedure #:clean #:enforce) srfi-4#s8vector->list ((struct s8vector)) (list-of fixnum)))

(srfi-4#s8vector-length (#(procedure #:clean #:enforce) srfi-4#s8vector-length ((struct s8vector)) fixnum)
		 (((struct s8vector)) (##core#inline "C_u_i_8vector_length" #(1))))

(srfi-4#s8vector-ref (#(procedure #:clean #:enforce) srfi-4#s8vector-ref ((struct s8vector) fixnum) fixnum))
(srfi-4#s8vector-set! (#(procedure #:clean #:enforce) srfi-4#s8vector-set! ((struct s8vector) fixnum fixnum) undefined))

(srfi-4#s8vector? (#(procedure #:pure #:predicate (struct s8vector)) srfi-4#s8vector? (*) boolean))

(srfi-4#subf32vector (#(procedure #:clean #:enforce) srfi-4#subf32vector ((struct f32vector) fixnum fixnum) (struct f32vector)))
(srfi-4#subf64vector (#(procedure #:clean #:enforce) srfi-4#subf64vector ((struct f64vector) fixnum fixnum) (struct f64vector)))
(srfi-4#subs16vector (#(procedure #:clean #:enforce) srfi-4#subs16vector ((struct s16vector) fixnum fixnum) (struct s16vector)))
(srfi-4#subs32vector (#(procedure #:clean #:enforce) srfi-4#subs32vector ((struct s32vector) fixnum fixnum) (struct s32vector)))
(srfi-4#subs8vector (#(procedure #:clean #:enforce) srfi-4#subs8vector  ((struct s8vector) fixnum fixnum) (struct s8vector)))
(srfi-4#subu16vector (#(procedure #:clean #:enforce) srfi-4#subu16vector ((struct u16vector) fixnum fixnum) (struct u16vector)))
(srfi-4#subu32vector (#(procedure #:clean #:enforce) srfi-4#subu32vector ((struct u32vector) fixnum fixnum) (struct u32vector)))
(srfi-4#subu64vector (#(procedure #:clean #:enforce) srfi-4#subu64vector ((struct u64vector) fixnum fixnum) (struct u64vector)))
(srfi-4#subu8vector (#(procedure #:clean #:enforce) srfi-4#subu8vector ((struct u8vector) fixnum fixnum) (struct u8vector)))
(srfi-4#u16vector (#(procedure #:clean #:enforce) srfi-4#u16vector (#!rest fixnum) (struct u16vector)))
(srfi-4#u16vector->blob (#(procedure #:clean #:enforce) srfi-4#u16vector->blob ((struct u16vector)) blob))
(srfi-4#u16vector->blob/shared (#(procedure #:clean #:enforce) srfi-4#u16vector->blob/shared ((struct u16vector)) blob))
(srfi-4#u16vector->list (#(procedure #:clean #:enforce) srfi-4#u16vector->list ((struct u16vector)) (list-of fixnum)))

(srfi-4#u16vector-length (#(procedure #:clean #:enforce) srfi-4#u16vector-length ((struct u16vector)) fixnum)
		  (((struct u16vector)) (##core#inline "C_u_i_16vector_length" #(1))))

(srfi-4#u16vector-ref (#(procedure #:clean #:enforce) srfi-4#u16vector-ref ((struct u16vector) fixnum) fixnum))
(srfi-4#u16vector-set! (#(procedure #:clean #:enforce) srfi-4#u16vector-set! ((struct u16vector) fixnum fixnum) undefined))

(srfi-4#u16vector? (#(procedure #:pure #:predicate (struct u16vector)) srfi-4#u16vector? (*) boolean))

(srfi-4#u32vector (#(procedure #:clean #:enforce) srfi-4#u32vector (#!rest integer) (struct u32vector)))
(srfi-4#u32vector->blob (#(procedure #:clean #:enforce) srfi-4#u32vector->blob ((struct u32vector)) blob))
(srfi-4#u32vector->blob/shared (#(procedure #:clean #:enforce) srfi-4#u32vector->blob/shared ((struct u32vector)) blob))
(srfi-4#u32vector->list (#(procedure #:clean #:enforce) srfi-4#u32vector->list ((struct u32vector)) (list-of integer)))

(srfi-4#u32vector-length (#(procedure #:clean #:enforce) srfi-4#u32vector-length ((struct u32vector)) fixnum)
		  (((struct u32vector)) (##core#inline "C_u_i_32vector_length" #(1))))

(srfi-4#u32vector-ref (#(procedure #:clean #:enforce) srfi-4#u32vector-ref ((struct u32vector) fixnum) integer))
(srfi-4#u32vector-set! (#(procedure #:clean #:enforce) srfi-4#u32vector-set! ((struct u32vector) fixnum integer) undefined))

(srfi-4#u32vector? (#(procedure #:pure #:predicate (struct u32vector)) srfi-4#u32vector? (*) boolean))

(srfi-4#u64vector (#(procedure #:clean #:enforce) srfi-4#u64vector (#!rest integer) (struct u64vector)))
(srfi-4#u64vector->blob (#(procedure #:clean #:enforce) srfi-4#u64vector->blob ((struct u64vector)) blob))
(srfi-4#u64vector->blob/shared (#(procedure #:clean #:enforce) srfi-4#u64vector->blob/shared ((struct u64vector)) blob))
(srfi-4#u64vector->list (#(procedure #:clean #:enforce) srfi-4#u64vector->list ((struct u64vector)) (list-of integer)))

(srfi-4#u64vector-length (#(procedure #:clean #:enforce) srfi-4#u64vector-length ((struct u64vector)) fixnum)
		  (((struct u64vector)) (##core#inline "C_u_i_64vector_length" #(1))))

(srfi-4#u64vector-ref (#(procedure #:clean #:enforce) srfi-4#u64vector-ref ((struct u64vector) fixnum) integer))
(srfi-4#u64vector-set! (#(procedure #:clean #:enforce) srfi-4#u64vector-set! ((struct u64vector) fixnum integer) undefined))

(srfi-4#u64vector? (#(procedure #:pure #:predicate (struct u64vector)) srfi-4#u64vector? (*) boolean))

(srfi-4#u8vector (#(procedure #:clean #:enforce) srfi-4#u8vector (#!rest fixnum) (struct u8vector)))
(srfi-4#u8vector->blob (#(procedure #:clean #:enforce) srfi-4#u8vector->blob ((struct u8vector)) blob))
(srfi-4#u8vector->blob/shared (#(procedure #:clean #:enforce) srfi-4#u8vector->blob/shared ((struct u8vector)) blob))
(srfi-4#u8vector->list (#(procedure #:clean #:enforce) srfi-4#u8vector->list ((struct u8vector)) (list-of fixnum)))

(srfi-4#u8vector-length (#(procedure #:clean #:enforce) srfi-4#u8vector-length ((struct u8vector)) fixnum)
		 (((struct u8vector)) (##core#inline "C_u_i_8vector_length" #(1))))

(srfi-4#u8vector-ref (#(procedure #:clean #:enforce) srfi-4#u8vector-ref ((struct u8vector) fixnum) fixnum))
(srfi-4#u8vector-set! (#(procedure #:clean #:enforce) srfi-4#u8vector-set! ((struct u8vector) fixnum fixnum) undefined))

(srfi-4#u8vector? (#(procedure #:pure #:predicate (struct u8vector)) srfi-4#u8vector? (*) boolean))

(srfi-4#write-u8vector (#(procedure #:enforce) srfi-4#write-u8vector ((struct u8vector) #!optional output-port fixnum fixnum) undefined))

(srfi-4#number-vector? (#(procedure #:pure #:predicate (or (struct u8vector) (struct u16vector) (struct s8vector) (struct s16vector) (struct u32vector) (struct s32vector) (struct u64vector) (struct s64vector) (struct f32vector) (struct f64vector))) srfi-4#number-vector? (*) boolean))
(##sys#srfi-4-vector? (#(procedure #:pure #:predicate (or (struct u8vector) (struct u16vector) (struct s8vector) (struct s16vector) (struct u32vector) (struct s32vector) (struct u64vector) (struct s64vector) (struct f32vector) (struct f64vector))) ##sys#srfi-4-vector? (*) boolean))


;; tcp

(chicken.tcp#tcp-abandon-port (#(procedure #:clean #:enforce) chicken.tcp#tcp-abandon-port (port) undefined))
(chicken.tcp#tcp-accept (#(procedure #:clean #:enforce) chicken.tcp#tcp-accept ((struct tcp-listener)) input-port output-port))
(chicken.tcp#tcp-accept-ready? (#(procedure #:clean #:enforce) chicken.tcp#tcp-accept-ready? ((struct tcp-listener)) boolean))
(chicken.tcp#tcp-accept-timeout (#(procedure #:clean #:enforce) chicken.tcp#tcp-accept-timeout (#!optional (or false integer)) (or false integer)))
(chicken.tcp#tcp-addresses (#(procedure #:clean #:enforce) chicken.tcp#tcp-addresses (port) string string))
(chicken.tcp#tcp-buffer-size (#(procedure #:clean #:enforce) chicken.tcp#tcp-buffer-size (#!optional (or false fixnum)) (or false fixnum)))
(chicken.tcp#tcp-close (#(procedure #:clean #:enforce) chicken.tcp#tcp-close ((struct tcp-listener)) undefined))
(chicken.tcp#tcp-connect (#(procedure #:clean #:enforce) chicken.tcp#tcp-connect (string #!optional fixnum) input-port output-port))
(chicken.tcp#tcp-connect-timeout (#(procedure #:clean #:enforce) chicken.tcp#tcp-connect-timeout (#!optional (or false integer)) (or false integer)))
(chicken.tcp#tcp-listen (#(procedure #:clean #:enforce) chicken.tcp#tcp-listen (fixnum #!optional fixnum *) (struct tcp-listener)))

(chicken.tcp#tcp-listener-fileno (#(procedure #:clean #:enforce) chicken.tcp#tcp-listener-fileno ((struct tcp-listener)) fixnum)
		     (((struct tcp-listener)) (##sys#slot #(1) '1)))

(chicken.tcp#tcp-listener-port (#(procedure #:clean #:enforce) chicken.tcp#tcp-listener-port ((struct tcp-listener)) fixnum))

(chicken.tcp#tcp-listener? (#(procedure #:clean #:predicate (struct tcp-listener)) chicken.tcp#tcp-listener? (*) boolean))

(chicken.tcp#tcp-port-numbers (#(procedure #:clean #:enforce) chicken.tcp#tcp-port-numbers (port) fixnum fixnum))
(chicken.tcp#tcp-read-timeout (#(procedure #:clean #:enforce) chicken.tcp#tcp-read-timeout (#!optional (or false integer)) (or false integer)))
(chicken.tcp#tcp-write-timeout (#(procedure #:clean #:enforce) chicken.tcp#tcp-write-timeout (#!optional (or false integer)) (or false integer)))


;; utils

(chicken.utils#system* (#(procedure #:clean #:enforce) chicken.utils#system* (string #!rest) undefined))
(chicken.utils#qs (#(procedure #:clean #:enforce) chicken.utils#qs (string) string))
(chicken.utils#compile-file (#(procedure #:clean #:enforce) chicken.utils#compile-file (string #!rest) (or false string)))
(chicken.utils#compile-file-options (#(procedure #:clean #:enforce) chicken.utils#compile-file-options (#!optional (list-of string)) (list-of string)))
